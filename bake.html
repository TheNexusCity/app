<html>
<head>
  <title>Webaverse Model Baker</title>
  <link rel=stylesheet type='text/css' href="index.css">
</head>
<body>

<script src="./bin/geometry.js"></script>
<script type=module>
  import * as THREE from './three.module.js';
  import slice from './slice.js';
  import App from './app.js';
  import {renderer, scene, camera, orthographicCamera} from './app-object.js';
  import {world} from './world.js';
  import * as universe from './universe.js';
  import {parseQuery, parseExtents, isInIframe} from './util.js';
  // import {homeScnUrl, rarityColors} from './constants.js';

  // window.slice = slice;

  const cameraPosition = new THREE.Vector3(0, 100, 0);
  const cameraTarget = new THREE.Vector3(cameraPosition.x, 0, cameraPosition.z);
  const perspectiveOffset = new THREE.Vector3(2, 0, -5);
  const iframed = isInIframe();
  // const loadDelayTime = 5000;

  renderer.setPixelRatio(window.devicePixelRatio);
  camera.up.set(0, 0, -1);

  const _getNumTriangles = geometry => {
    const {attributes: {position}, index} = geometry;
    if (index) {
      return index.array.length/3;
    } else if (position) {
      return position.array.length/9;
    } else {
      return 0;
    }
  };

  (async () => {
    const q = parseQuery(location.search);
    if (q.u) {
      const app = new App();

      await app.waitForLoad();
      const object = await world.addObject(q.u, null, new THREE.Vector3(), new THREE.Quaternion());
      // window.object = object;
      object.updateMatrixWorld();
      // const replacementMeshes = [];
      const w = 30;
      const box = new THREE.Box3(
        new THREE.Vector3(-w/2, 0, -w/2),
        new THREE.Vector3(w/2, w, w/2)
      );
      const planes = [
        new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), box.min),
        new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, -1, 0), box.max),
        new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(1, 0, 0), box.min),
        new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(-1, 0, 0), box.max),
        new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 0, 1), box.min),
        new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 0, -1), box.max),
      ];
      const geometryMap = {};
      const materialMap = {};
      object.traverse(o => {
        if (o.isMesh) {
          const oldGeometry = o.geometry;
          const oldMaterial = o.material;

          let geometry = geometryMap[oldGeometry.uuid];
          if (!geometry) {
            geometry = new THREE.Geometry().fromBufferGeometry(o.geometry.clone().applyMatrix4(o.matrixWorld));

            for (const plane of planes) {
              geometry = slice(geometry, plane);
            }

            geometry = new THREE.BufferGeometry().fromGeometry(geometry)
              .applyMatrix4(o.matrixWorld.clone().invert());
          }
          o.geometry = geometry;

          geometryMap[oldGeometry.uuid] = geometry;
          materialMap[oldMaterial.uuid] = oldMaterial;

          /* const boxBsp = CSG.fromGeometry(new THREE.BoxBufferGeometry(1, 1));
          const meshBsp = CSG.fromMesh(o);
          console.log('got bsp 1', meshBsp);
          const bspResult = meshBsp.intersect(meshBsp);
          console.log('got bsp 2', bspResult);
          const meshResult = CSG.toMesh(bspResult, o.matrix);
          meshResult.material = o.material;
          replacementMeshes.push({
            from: o,
            to: meshResult,
          }); */
        }
      });

      camera.position.set(0, 1, 2);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      renderer.clear();
      app.render();

      const geometries = Object.keys(geometryMap).map(k => geometryMap[k]);
      const materials = Object.keys(materialMap).map(k => materialMap[k]);
      document.body.appendChild(renderer.domElement);

      const numMeshes = geometries.length;
      const numMaterials = materials.length;
      let numTriangles = 0;
      for (const geometry of geometries) {
        numTriangles += _getNumTriangles(geometry);
      }

      console.log('got', {numMeshes, numMaterials, numTriangles}, {geometries, materials});

      /* for (const {from, to} of replacementMeshes) {
        console.log('replacing', from, to);
        const {parent} = from;
        const index = parent.children.indexOf(from);
        parent.remove(from);
        parent.add(to);
        parent.children.length -= 1;
        parent.children.splice(index, 0, to);
      } */
    }
  })().catch(console.warn);
</script>
</body>

</html>

<html>
<head>
  <title>Webaverse Model Baker</title>
  <link rel=stylesheet type='text/css' href="index.css">
</head>
<body>

<script src="./bin/geometry.js"></script>
<script type=module>
  import * as THREE from './three.module.js';
  // import {CSG} from './three-csg.js';
  import slice from './slice.js';
  import App from './app.js';
  import {renderer, scene, camera, orthographicCamera} from './app-object.js';
  import {world} from './world.js';
  import * as universe from './universe.js';
  import {parseQuery, parseExtents, isInIframe} from './util.js';
  // import {homeScnUrl, rarityColors} from './constants.js';

  window.CSG = CSG;
  window.slice = slice;

  const cameraPosition = new THREE.Vector3(0, 100, 0);
  const cameraTarget = new THREE.Vector3(cameraPosition.x, 0, cameraPosition.z);
  const perspectiveOffset = new THREE.Vector3(2, 0, -5);
  const iframed = isInIframe();
  // const loadDelayTime = 5000;

  renderer.setPixelRatio(window.devicePixelRatio);
  camera.up.set(0, 0, -1);

  (async () => {
    const q = parseQuery(location.search);
    if (q.u) {
      const app = new App();

      await app.waitForLoad();
      const object = await world.addObject(q.u, null, new THREE.Vector3(), new THREE.Quaternion());
      // window.object = object;
      object.updateMatrixWorld();
      // const replacementMeshes = [];
      const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(1, 0, 0), new THREE.Vector3());
      object.traverse(o => {
        if (o.isMesh) {
          const oldGeometryeometry = new THREE.Geometry().fromBufferGeometry(o.geometry.clone().applyMatrix4(o.matrixWorld));
          const newGeometry = new THREE.BufferGeometry().fromGeometry(slice(oldGeometryeometry, plane).applyMatrix4(o.matrixWorld.clone().invert()));
          o.geometry = newGeometry;
          /* const boxBsp = CSG.fromGeometry(new THREE.BoxBufferGeometry(1, 1));
          const meshBsp = CSG.fromMesh(o);
          console.log('got bsp 1', meshBsp);
          const bspResult = meshBsp.intersect(meshBsp);
          console.log('got bsp 2', bspResult);
          const meshResult = CSG.toMesh(bspResult, o.matrix);
          meshResult.material = o.material;
          replacementMeshes.push({
            from: o,
            to: meshResult,
          }); */
        }
      });

      camera.position.set(0, 1, 2);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      renderer.clear();
      app.render();

      document.body.appendChild(renderer.domElement);

      /* for (const {from, to} of replacementMeshes) {
        console.log('replacing', from, to);
        const {parent} = from;
        const index = parent.children.indexOf(from);
        parent.remove(from);
        parent.add(to);
        parent.children.length -= 1;
        parent.children.splice(index, 0, to);
      } */
    }
  })().catch(console.warn);
</script>
</body>

</html>

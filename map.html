<html>
<head>
  <title>Webaverse Map</title>
  <link rel=stylesheet type='text/css' href="map.css">
</head>
<body>
  <div id=container class=container></div>

<script src="./bin/geometry.js"></script>
<script type=module>
  import * as THREE from './three.module.js';
  import App from './app.js';
  import {camera, orthographicCamera, renderer} from './app-object.js';
  import {world} from './world.js';
  import {parseQuery} from './util.js';
  import {homeScnUrl, rarityColors} from './constants.js';

  const width = 128;
  const height = 128;
  const cameraPosition = new THREE.Vector3(0, 100, 0);
  const cameraTarget = new THREE.Vector3(cameraPosition.x, 0, cameraPosition.z);
  const perspectiveOffset = new THREE.Vector3(2, 0, -5);

  renderer.setSize(width, height);
  renderer.setPixelRatio(2);

  camera.aspect = width/height;
  camera.updateProjectionMatrix();
  camera.up.set(0, 0, -1);

  const tileScale = 16;
  let zoom = 1;

  (async () => {
    const app = new App();
    const [
      appResult,
      parcelsJson,
    ] = await Promise.all([
      (async () => {
        await app.waitForLoad();
        await world.addObject(homeScnUrl, null, new THREE.Vector3(), new THREE.Quaternion());
      })(),
      (async () => {
        const res = await fetch(`https://webaverse.github.io/parcels/parcels.json`);
        const j = await res.json();
        return j;
      })(),
    ]);

    // fixes a glitch where the first render has black opaque
    app.render();

    const container = document.getElementById('container');
    const containerSize = 10000;
    container.style.width = `${containerSize}px`;
    container.style.height = `${containerSize}px`;
    container.style.left = `-${containerSize/2}px`;
    container.style.top = `-${containerSize/2}px`;
    const _getContainerMetrics = () => new THREE.Vector2(parseInt(container.style.left || '0', 10), parseInt(container.style.top || '0', 10));

    const {dst} = parseQuery(location.search);
    if (!dst) {
      setTimeout(() => { // wait for load; should really be a lock
        // console.time('render');

        const _getTileId = (x, z) => `tile-${x}-${z}`;
        const _renderParcel = (x, z) => {
          orthographicCamera.left = -tileScale*zoom/2;
          orthographicCamera.right = tileScale*zoom/2;
          orthographicCamera.top = tileScale*zoom/2;
          orthographicCamera.bottom = -tileScale*zoom/2;
          orthographicCamera.near = 0;
          orthographicCamera.far = 2000;
          orthographicCamera.updateProjectionMatrix();
          camera.projectionMatrix.copy(orthographicCamera.projectionMatrix);
        
          const offset = new THREE.Vector3((x + 0.5) * tileScale * zoom, 0, (z + 0.5) * tileScale * zoom);
          camera.position.copy(cameraPosition).add(offset);
          camera.lookAt(cameraTarget.clone().add(offset).add(perspectiveOffset));

          renderer.clear();
          app.render();
        
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          canvas.style.position = 'absolute';
          canvas.id = _getTileId(x, z);
          const containerMetrics = _getContainerMetrics();
          canvas.style.left = (containerSize/2) + (x*width) + 'px';
          canvas.style.top = (containerSize/2) + (z*height) + 'px';
          const ctx = canvas.getContext('2d');
          ctx.drawImage(renderer.domElement, 0, 0, canvas.width, canvas.height);
          container.appendChild(canvas);
        };
        const _getNeededCoords = (topLeftPosition, boundingBox) => {
          const result = [];
          const maxX = Math.ceil((topLeftPosition.x + boundingBox.width)/width)*width;
          const maxZ = Math.ceil((topLeftPosition.y + boundingBox.height)/height)*height;
          for (let x = topLeftPosition.x; x < maxX; x += width) {
            for (let z = topLeftPosition.y; z < maxZ; z += height) {
              const ax = Math.floor(x/width);
              const az = Math.floor(z/height);
              result.push(new THREE.Vector2(ax, az));
            }
          }
          return result;
        };
        
        let currentTiles = [];
        const _updateTiles = () => {
          const topLeftPosition = _getContainerMetrics().multiplyScalar(-1).sub(new THREE.Vector2(containerSize/2, containerSize/2));
          const boundingBox = document.body.getBoundingClientRect();
          const neededCoords = _getNeededCoords(topLeftPosition, boundingBox);
          for (const v of neededCoords) {
            if (!currentTiles.some(t => t.equals(v))) {
              _renderParcel(v.x, v.y);
            }
          }
          for (const v of currentTiles) {
            if (!neededCoords.some(t => t.equals(v))) {
              const tileId = _getTileId(v.x, v.y);
              const tileEl = document.getElementById(tileId);
              tileEl.parentNode.removeChild(tileEl);
            }
          }
          currentTiles = neededCoords;
        };
        _updateTiles();
        
        let dragSpec = null;
        const _startDrag = e => {
          dragSpec = {
            startPosition: _getContainerMetrics(),
            startX: e.clientX,
            startY: e.clientY,
          };
          container.classList.add('dragging');
        };
        const _endDrag = () => {
          dragSpec = null;
          container.classList.remove('dragging');
          _updateTiles();
        };
        container.addEventListener('mousedown', e => {
          _startDrag(e);
        });
        window.addEventListener('mouseup', e => {
          _endDrag();
        });
        container.addEventListener('mousemove', e => {
          if (dragSpec) {
            const currentX = e.clientX;
            const currentY = e.clientY;
            const diffX = e.clientX - dragSpec.startX;
            const diffY = e.clientY - dragSpec.startY;
            const newPosition = dragSpec.startPosition.clone()
              .add(new THREE.Vector2(diffX, diffY));
            container.style.left = `${newPosition.x}px`;
            container.style.top = `${newPosition.y}px`;
          }
          
          /* const containerMetrics = _getContainerMetrics();
          const clickPoint = new THREE.Vector2(
            (-containerMetrics.x - (containerSize/2) + e.clientX)/width*(tileScale*zoom) + perspectiveOffset.x,
            (-containerMetrics.y - (containerSize/2) + e.clientY)/height*(tileScale*zoom) + perspectiveOffset.z,
          );
          console.log(clickPoint.toArray().join(', ')); */
        });
        window.addEventListener('resize', e => {
          _updateTiles();
        });
        container.addEventListener('wheel', e => {
          const containerMetrics = _getContainerMetrics();
          const mouseWorldPosition = new THREE.Vector2(
            (-containerMetrics.x - (containerSize/2) + e.clientX)/width*(tileScale*zoom),
            (-containerMetrics.y - (containerSize/2) + e.clientY)/height*(tileScale*zoom),
          );

          zoom = Math.min(Math.max(zoom * (1 + e.deltaY * 0.001), 0.01), 100);
          container.innerHTML = '';
          currentTiles = [];

          container.style.left = `${-containerSize/2 + e.clientX - mouseWorldPosition.x*width/(tileScale*zoom)}px`;
          container.style.top = `${-containerSize/2 + e.clientY - mouseWorldPosition.y*height/(tileScale*zoom)}px`;

          _updateTiles();
          _renderAnchors();
        });
        container.addEventListener('dblclick', e => {
          const containerMetrics = _getContainerMetrics();
          const clickPoint = new THREE.Vector3(
            (-containerMetrics.x - (containerSize/2) + e.clientX)/width*(tileScale*zoom) + perspectiveOffset.x,
            2,
            (-containerMetrics.y - (containerSize/2) + e.clientY)/height*(tileScale*zoom) + perspectiveOffset.z,
          );

          const a = document.createElement('a');
          a.href = _getCoordUrl(clickPoint);
          a.click();
        });

        console.timeEnd('render');
      }, 5000);
      
      const _getCoordUrl = c => `https://app.webaverse.com/?c=${JSON.stringify([c.x, c.y, c.z])}`;
      const _renderAnchors = () => {
        for (const p of parcelsJson) {
          const {name, rarity, extents} = p;
          const [[x1, y1, z1], [x2, y2, z2]] = extents;
          const box = new THREE.Box3(
            new THREE.Vector3(x1, y1, z1),
            new THREE.Vector3(x2, y2, z2),
          );
          const center = box.getCenter(new THREE.Vector3());
          const div = document.createElement('a');
          div.href = _getCoordUrl(center);
          div.classList.add('parcel');
          const colors = (rarityColors[rarity] || rarityColors.legendary).map(c => new THREE.Color(c));
          div.style.background = `radial-gradient(${colors.map(c => '#' + c.getHexString()).join(', ')})`;
          div.innerHTML = `\
            <div class=details>${p.name}</div>
          `;
          div.addEventListener('mousedown', e => {
            e.stopPropagation();
          });
          const localWidth = (x2-x1)*width/(tileScale*zoom);
          const localHeight = (z2-z1)*height/(tileScale*zoom);
          div.style.left = (containerSize/2) + (x1*width/(tileScale*zoom)) - (perspectiveOffset.x*width/(tileScale*zoom)) + `px`;
          div.style.top = (containerSize/2) + (z1*height/(tileScale*zoom)) - (perspectiveOffset.z*height/(tileScale*zoom)) + `px`;
          div.style.width = localWidth + `px`;
          div.style.height = localHeight + `px`;
          container.appendChild(div);
        }
      };
      _renderAnchors();
    } else {
      let {x, y, sw, sh, dw, dh} = parseQuery(location.search);

      x = parseInt(x);
      y = parseInt(y);
      sw = parseInt(sw);
      sh = parseInt(sh);
      dw = parseInt(dw);
      dh = parseInt(dh);

      orthographicCamera.left = -sw/2;
      orthographicCamera.right = sw/2;
      orthographicCamera.top = sh/2;
      orthographicCamera.bottom = -sh/2;
      orthographicCamera.near = 0;
      orthographicCamera.far = 2000;
      orthographicCamera.updateProjectionMatrix();
      camera.projectionMatrix.copy(orthographicCamera.projectionMatrix);

      cameraTarget.set(x + sw/2, 0, y + sh/2);

      const offset = new THREE.Vector3(x * tileScale, 0, y * tileScale);
      camera.position.copy(cameraPosition).add(offset);
      camera.lookAt(cameraTarget.clone().add(offset).add(new THREE.Vector3(2, 0, -5)));

      renderer.setSize(dw, dh);

      renderer.clear();
      app.render();

      container.appendChild(renderer.domElement);

      const blob = await new Promise((accept, reject) => {
        renderer.domElement.toBlob(accept);
      });

      fetch(dst, {
        method: 'POST',
        headers: {
          'Content-Type': 'image/png',
        },
        body: blob,
      }).then(res => res.blob());

      /* const arrayBuffer = await blob.arrayBuffer();
      window.parent.postMessage({
        method: 'result',
        result: arrayBuffer,
      }, '*', [arrayBuffer]); */
    }
  })();
</script>
</body>

</html>

<html>
<head>
  <title>Webaverse Map</title>
  <link rel=stylesheet type='text/css' href="map.css">
</head>
<body>
  <div id=container></div>

<script src="./bin/geometry.js"></script>
<script type=module>
  import * as THREE from './three.module.js';
  import App from './app.js';
  import {camera, orthographicCamera, renderer} from './app-object.js';
  import {world} from './world.js';
  import {parseQuery} from './util.js';
  import {homeScnUrl} from './constants.js';

  const width = 128;
  const height = 128;
  const cameraPosition = new THREE.Vector3(0, 100, -2);
  const cameraTarget = new THREE.Vector3(cameraPosition.x, 0, cameraPosition.z);

  /* const renderer = new THREE.WebGLRenderer({
    alpha: true,
    antialias: true,
  });
  renderer.setSize(width, height);

  const scene = new THREE.Scene();

  const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
  directionalLight.position.set(2, 2, -2);
  scene.add(directionalLight);
  const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 1);
  directionalLight2.position.set(-2, 2, 2);
  scene.add(directionalLight2); */

  renderer.setSize(width, height);
  renderer.setPixelRatio(2);

  camera.aspect = width/height;
  camera.updateProjectionMatrix();
  camera.up.set(0, 0, -1);

  const tileScale = 16;

  (async () => {
    const app = new App();
    await app.waitForLoad();

    await world.addObject(homeScnUrl, null, new THREE.Vector3(), new THREE.Quaternion());

    // fixes a glitch where the first render has black opaque
    app.render();

    const {dst} = parseQuery(location.search);
    if (!dst) {
      const w = 10;
      const h = 12;

      setTimeout(() => { // wait for load; should really be a lock
        orthographicCamera.left = -tileScale/2;
        orthographicCamera.right = tileScale/2;
        orthographicCamera.top = tileScale/2;
        orthographicCamera.bottom = -tileScale/2;
        orthographicCamera.near = 0;
        orthographicCamera.far = 2000;
        orthographicCamera.updateProjectionMatrix();
        camera.projectionMatrix.copy(orthographicCamera.projectionMatrix);

        // document.body.appendChild(renderer.domElement);

        for (let x = -w; x < w; x++) {
          for (let z = -h; z < h; z++) {
            const offset = new THREE.Vector3(x * tileScale, 0, z * tileScale);
            camera.position.copy(cameraPosition).add(offset);
            camera.lookAt(cameraTarget.clone().add(offset).add(new THREE.Vector3(2, 0, -5)));

            renderer.clear();
            app.render();
          
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            canvas.style.position = 'absolute';
            canvas.style.left = ((w + x)*width) + 'px';
            canvas.style.top = ((h + z)*height) + 'px';
            const ctx = canvas.getContext('2d');
            ctx.drawImage(renderer.domElement, 0, 0, canvas.width, canvas.height);
            document.body.appendChild(canvas);
          }
        }
      }, 5000);
      
      (async () => {
        const res = await fetch(`https://webaverse.github.io/parcels/parcels.json`);
        const ps = await res.json();
        for (const p of ps) {
          const {extents} = p;
          const [[x1, y1, z1], [x2, y2, z2]] = extents;
          const box = new THREE.Box3(
            new THREE.Vector3(x1, y1, z1),
            new THREE.Vector3(x2, y2, z2),
          );
          const center = box.getCenter(new THREE.Vector3());
          const div = document.createElement('a');
          div.href = `https://app.webaverse.com/?c=${JSON.stringify([center.x, center.y, center.z])}`;
          div.classList.add('parcel');
          div.innerHTML = `\
            <div class=details>${p.name}</div>
          `;
          const localWidth = (x2-x1)*width/tileScale;
          const localHeight = (z2-z1)*height/tileScale;
          div.style.left = (width*(w+0.5)) - (localWidth/2) + (x1*width/tileScale) + `px`;
          div.style.top = (height*(h+1)) - (localHeight/2) + (z1*height/tileScale) + `px`;
          div.style.width = localWidth + `px`;
          div.style.height = localHeight + `px`;
          document.body.appendChild(div);
        }
      })();
    } else {
      let {x, y, sw, sh, dw, dh} = parseQuery(location.search);

      x = parseInt(x);
      y = parseInt(y);
      sw = parseInt(sw);
      sh = parseInt(sh);
      dw = parseInt(dw);
      dh = parseInt(dh);

      orthographicCamera.left = -sw/2;
      orthographicCamera.right = sw/2;
      orthographicCamera.top = sh/2;
      orthographicCamera.bottom = -sh/2;
      orthographicCamera.near = 0;
      orthographicCamera.far = 2000;
      orthographicCamera.updateProjectionMatrix();
      camera.projectionMatrix.copy(orthographicCamera.projectionMatrix);

      cameraTarget.set(x + sw/2, 0, y + sh/2);

      const offset = new THREE.Vector3(x * tileScale, 0, y * tileScale);
      camera.position.copy(cameraPosition).add(offset);
      camera.lookAt(cameraTarget.clone().add(offset).add(new THREE.Vector3(2, 0, -5)));

      renderer.setSize(dw, dh);

      renderer.clear();
      app.render();

      document.body.appendChild(renderer.domElement);

      const blob = await new Promise((accept, reject) => {
        renderer.domElement.toBlob(accept);
      });

      fetch(dst, {
        method: 'POST',
        headers: {
          'Content-Type': 'image/png',
        },
        body: blob,
      }).then(res => res.blob());

      /* const arrayBuffer = await blob.arrayBuffer();
      window.parent.postMessage({
        method: 'result',
        result: arrayBuffer,
      }, '*', [arrayBuffer]); */
    }
  })();
</script>
</body>

</html>

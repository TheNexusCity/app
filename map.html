<html>
<head>
  <title>Webaverse Map</title>
  <link rel=stylesheet type='text/css' href="map.css">
</head>
<body>
  <div id=container class=container></div>

<script src="./bin/geometry.js"></script>
<script type=module>
  import * as THREE from './three.module.js';
  import App from './app.js';
  import {camera, orthographicCamera, renderer} from './app-object.js';
  import {world} from './world.js';
  import {parseQuery} from './util.js';
  import {homeScnUrl} from './constants.js';

  const width = 128;
  const height = 128;
  const cameraPosition = new THREE.Vector3(0, 100, -2);
  const cameraTarget = new THREE.Vector3(cameraPosition.x, 0, cameraPosition.z);

  renderer.setSize(width, height);
  renderer.setPixelRatio(2);

  camera.aspect = width/height;
  camera.updateProjectionMatrix();
  camera.up.set(0, 0, -1);

  const tileScale = 16;

  (async () => {
    const app = new App();
    await app.waitForLoad();

    await world.addObject(homeScnUrl, null, new THREE.Vector3(), new THREE.Quaternion());

    // fixes a glitch where the first render has black opaque
    app.render();

    const container = document.getElementById('container');

    const {dst} = parseQuery(location.search);
    if (!dst) {
      const w = 10;
      const h = 12;

      let dragSpec = null;
      container.addEventListener('mousedown', e => {
        dragSpec = {
          startPosition: new THREE.Vector2(parseInt(container.style.left || '0', 10), parseInt(container.style.top || '0', 10)),
          startX: e.clientX,
          startY: e.clientY,
        };
      });
      window.addEventListener('mouseup', e => {
        dragSpec = null;
      });
      container.addEventListener('mousemove', e => {
        if (dragSpec) {
          const currentX = e.clientX;
          const currentY = e.clientY;
          const diffX = e.clientX - dragSpec.startX;
          const diffY = e.clientY - dragSpec.startY;
          const newPosition = dragSpec.startPosition.clone()
            .add(new THREE.Vector2(diffX, diffY));
          container.style.left = `${newPosition.x}px`;
          container.style.top = `${newPosition.y}px`;
        }
      });

      setTimeout(() => { // wait for load; should really be a lock
        console.time('render');
      
        orthographicCamera.left = -tileScale/2;
        orthographicCamera.right = tileScale/2;
        orthographicCamera.top = tileScale/2;
        orthographicCamera.bottom = -tileScale/2;
        orthographicCamera.near = 0;
        orthographicCamera.far = 2000;
        orthographicCamera.updateProjectionMatrix();
        camera.projectionMatrix.copy(orthographicCamera.projectionMatrix);

        // document.body.appendChild(renderer.domElement);

        const _renderParcel = (x, z) => {
          const offset = new THREE.Vector3(x * tileScale, 0, z * tileScale);
          camera.position.copy(cameraPosition).add(offset);
          camera.lookAt(cameraTarget.clone().add(offset).add(new THREE.Vector3(2, 0, -5)));

          renderer.clear();
          app.render();
        
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          canvas.style.position = 'absolute';
          canvas.style.left = (x*width) + 'px';
          canvas.style.top = (z*height) + 'px';
          const ctx = canvas.getContext('2d');
          ctx.drawImage(renderer.domElement, 0, 0, canvas.width, canvas.height);
          container.appendChild(canvas);
        };
        const _getNeededCoords = (topLeftPosition, boundingBox) => {
          const result = [];
          for (let x = topLeftPosition.x; x < (topLeftPosition.x + boundingBox.width); x += width) {
            for (let z = topLeftPosition.y; z < (topLeftPosition.y + boundingBox.height); z += height) {
              const ax = Math.floor(x/width);
              const az = Math.floor(z/height);
              result.push(new THREE.Vector2(ax, az));
            }
          }
          return result;
        };

        const topLeftPosition = new THREE.Vector2(0, 0);
        const boundingBox = container.getBoundingClientRect();
        const neededCoords = _getNeededCoords(topLeftPosition, boundingBox);
        for (const v of neededCoords) {
          const {x, y: z} = v;
          _renderParcel(x, z);
        }

        console.timeEnd('render');
      }, 2000);
      
      (async () => {
        const res = await fetch(`https://webaverse.github.io/parcels/parcels.json`);
        const ps = await res.json();
        for (const p of ps) {
          const {extents} = p;
          const [[x1, y1, z1], [x2, y2, z2]] = extents;
          const box = new THREE.Box3(
            new THREE.Vector3(x1, y1, z1),
            new THREE.Vector3(x2, y2, z2),
          );
          const center = box.getCenter(new THREE.Vector3());
          const div = document.createElement('a');
          div.href = `https://app.webaverse.com/?c=${JSON.stringify([center.x, center.y, center.z])}`;
          div.classList.add('parcel');
          div.innerHTML = `\
            <div class=details>${p.name}</div>
          `;
          div.addEventListener('mousedown', e => {
            e.stopPropagation();
          });
          const localWidth = (x2-x1)*width/tileScale;
          const localHeight = (z2-z1)*height/tileScale;
          div.style.left = (width*(w+0.5)) - (localWidth/2) + (x1*width/tileScale) + `px`;
          div.style.top = (height*(h+1)) - (localHeight/2) + (z1*height/tileScale) + `px`;
          div.style.width = localWidth + `px`;
          div.style.height = localHeight + `px`;
          container.appendChild(div);
        }
      })();
    } else {
      let {x, y, sw, sh, dw, dh} = parseQuery(location.search);

      x = parseInt(x);
      y = parseInt(y);
      sw = parseInt(sw);
      sh = parseInt(sh);
      dw = parseInt(dw);
      dh = parseInt(dh);

      orthographicCamera.left = -sw/2;
      orthographicCamera.right = sw/2;
      orthographicCamera.top = sh/2;
      orthographicCamera.bottom = -sh/2;
      orthographicCamera.near = 0;
      orthographicCamera.far = 2000;
      orthographicCamera.updateProjectionMatrix();
      camera.projectionMatrix.copy(orthographicCamera.projectionMatrix);

      cameraTarget.set(x + sw/2, 0, y + sh/2);

      const offset = new THREE.Vector3(x * tileScale, 0, y * tileScale);
      camera.position.copy(cameraPosition).add(offset);
      camera.lookAt(cameraTarget.clone().add(offset).add(new THREE.Vector3(2, 0, -5)));

      renderer.setSize(dw, dh);

      renderer.clear();
      app.render();

      container.appendChild(renderer.domElement);

      const blob = await new Promise((accept, reject) => {
        renderer.domElement.toBlob(accept);
      });

      fetch(dst, {
        method: 'POST',
        headers: {
          'Content-Type': 'image/png',
        },
        body: blob,
      }).then(res => res.blob());

      /* const arrayBuffer = await blob.arrayBuffer();
      window.parent.postMessage({
        method: 'result',
        result: arrayBuffer,
      }, '*', [arrayBuffer]); */
    }
  })();
</script>
</body>

</html>

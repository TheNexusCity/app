<html>
<head>
  <title>Webaverse Map</title>
  <link rel=stylesheet type='text/css' href="map.css">
</head>
<body>
  <div id=container></div>

<script src="./bin/geometry.js"></script>
<script type=module>
  import * as THREE from './three.module.js';
  import App from './app.js';
  import {camera, orthographicCamera, renderer} from './app-object.js';
  import {world} from './world.js';
  import {homeScnUrl} from './constants.js';

  const width = 128;
  const height = 128;
  const cameraPosition = new THREE.Vector3(0, 100, -2);
  const cameraTarget = new THREE.Vector3(cameraPosition.x, 0, cameraPosition.z);

  /* const renderer = new THREE.WebGLRenderer({
    alpha: true,
    antialias: true,
  });
  renderer.setSize(width, height);

  const scene = new THREE.Scene();

  const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
  directionalLight.position.set(2, 2, -2);
  scene.add(directionalLight);
  const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 1);
  directionalLight2.position.set(-2, 2, 2);
  scene.add(directionalLight2); */

  renderer.setSize(width, height);
  renderer.setPixelRatio(2);

  camera.aspect = width/height;
  camera.updateProjectionMatrix();
  camera.up.set(0, 0, -1);

  // const w = 4;
  const s = 16;
  const w = 10;
  const h = 12;

  orthographicCamera.left = -s/2;
  orthographicCamera.right = s/2;
  orthographicCamera.top = s/2;
  orthographicCamera.bottom = -s/2;
  orthographicCamera.near = 0;
  orthographicCamera.far = 2000;
  orthographicCamera.updateProjectionMatrix();
  camera.projectionMatrix.copy(orthographicCamera.projectionMatrix);

  (async () => {
    const app = new App();
    await app.waitForLoad();

    await world.addObject(homeScnUrl, null, new THREE.Vector3(), new THREE.Quaternion());

    // fixes a glitch where the first render has black opaque
    app.render();

    setTimeout(() => {
      // document.body.appendChild(renderer.domElement);

      for (let x = -w; x < w; x++) {
        for (let z = -h; z < h; z++) {
          const v = new THREE.Vector3(x * s, 0, z * s);
          camera.position.copy(cameraPosition).add(v);
          camera.lookAt(cameraTarget.clone().add(v).add(new THREE.Vector3(2, 0, -w/2)));

          renderer.clear();
          app.render();
        
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          canvas.style.position = 'absolute';
          canvas.style.left = ((w + x)*width) + 'px';
          canvas.style.top = ((h + z)*height) + 'px';
          const ctx = canvas.getContext('2d');
          ctx.drawImage(renderer.domElement, 0, 0, canvas.width, canvas.height);
          document.body.appendChild(canvas);
        }
      }
    }, 5000);

    /* if (dst) {
      fetch(dst, {
        method: 'POST',
        headers: {
          'Content-Type': mimeType,
        },
        body: arrayBuffer,
      }).then(res => res.blob());
    }

    window.parent.postMessage({
      method: 'result',
      result: arrayBuffer,
    }, '*', [arrayBuffer]); */
  })();
  (async () => {
    const res = await fetch(`https://webaverse.github.io/parcels/parcels.json`);
    const ps = await res.json();
    for (const p of ps) {
      const {extents} = p;
      const div = document.createElement('div');
      div.classList.add('parcel');
      const [[x1, y1, z1], [x2, y2, z2]] = extents;
      const localWidth = (x2-x1)*width/s;
      const localHeight = (z2-z1)*height/s;
      div.style.left = (width*(w+0.5)) - (localWidth/2) + (x1*width/s) + `px`;
      div.style.top = (height*(h+1)) - (localHeight/2) + (z1*height/s) + `px`;
      div.style.width = localWidth + `px`;
      div.style.height = localHeight + `px`;
      document.body.appendChild(div);
    }
  })();
</script>
</body>

</html>

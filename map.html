<html>
<head>
  <title>Webaverse Map</title>
  <link rel=stylesheet type='text/css' href="map.css">
</head>
<body>
  <div id=container class=container></div>

<script src="./bin/geometry.js"></script>
<script type=module>
  import * as THREE from './three.module.js';
  import App from './app.js';
  import {camera, orthographicCamera, renderer} from './app-object.js';
  import {world} from './world.js';
  import {parseQuery} from './util.js';
  import {homeScnUrl} from './constants.js';

  const width = 128;
  const height = 128;
  const cameraPosition = new THREE.Vector3(0, 100, 0);
  const cameraTarget = new THREE.Vector3(cameraPosition.x, 0, cameraPosition.z);
  const perspectiveOffset = new THREE.Vector3(2, 0, -5);

  renderer.setSize(width, height);
  renderer.setPixelRatio(2);

  camera.aspect = width/height;
  camera.updateProjectionMatrix();
  camera.up.set(0, 0, -1);

  const tileScale = 16;

  (async () => {
    const app = new App();
    await app.waitForLoad();

    await world.addObject(homeScnUrl, null, new THREE.Vector3(), new THREE.Quaternion());

    // fixes a glitch where the first render has black opaque
    app.render();

    const container = document.getElementById('container');
    const containerSize = 10000;
    container.style.width = `${containerSize}px`;
    container.style.height = `${containerSize}px`;
    container.style.left = `-${containerSize/2}px`;
    container.style.top = `-${containerSize/2}px`;
    const _getContainerMetrics = () => new THREE.Vector2(parseInt(container.style.left || '0', 10), parseInt(container.style.top || '0', 10));

    const {dst} = parseQuery(location.search);
    if (!dst) {
      setTimeout(() => { // wait for load; should really be a lock
        console.time('render');
      
        orthographicCamera.left = -tileScale/2;
        orthographicCamera.right = tileScale/2;
        orthographicCamera.top = tileScale/2;
        orthographicCamera.bottom = -tileScale/2;
        orthographicCamera.near = 0;
        orthographicCamera.far = 2000;
        orthographicCamera.updateProjectionMatrix();
        camera.projectionMatrix.copy(orthographicCamera.projectionMatrix);

        // document.body.appendChild(renderer.domElement);

        const _getTileId = (x, z) => `tile-${x}-${z}`;
        const _renderParcel = (x, z) => {
          const offset = new THREE.Vector3((x+0.5) * tileScale, 0, (z+0.5) * tileScale);
          camera.position.copy(cameraPosition).add(offset);
          camera.lookAt(cameraTarget.clone().add(offset).add(perspectiveOffset));

          renderer.clear();
          app.render();
        
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          canvas.style.position = 'absolute';
          canvas.id = _getTileId(x, z);
          const containerMetrics = _getContainerMetrics();
          canvas.style.left = (containerSize/2) + (x*width) + 'px';
          canvas.style.top = (containerSize/2) + (z*height) + 'px';
          const ctx = canvas.getContext('2d');
          ctx.drawImage(renderer.domElement, 0, 0, canvas.width, canvas.height);
          container.appendChild(canvas);
        };
        const _getNeededCoords = (topLeftPosition, boundingBox) => {
          const result = [];
          const maxX = Math.ceil((topLeftPosition.x + boundingBox.width)/width)*width;
          const maxZ = Math.ceil((topLeftPosition.y + boundingBox.height)/height)*height;
          for (let x = topLeftPosition.x; x < maxX; x += width) {
            for (let z = topLeftPosition.y; z < maxZ; z += height) {
              const ax = Math.floor(x/width);
              const az = Math.floor(z/height);
              result.push(new THREE.Vector2(ax, az));
            }
          }
          return result;
        };
        
        let currentTiles = [];
        const _updateTiles = () => {
          const topLeftPosition = _getContainerMetrics().multiplyScalar(-1).sub(new THREE.Vector2(containerSize/2, containerSize/2));
          const boundingBox = document.body.getBoundingClientRect();
          const neededCoords = _getNeededCoords(topLeftPosition, boundingBox);
          for (const v of neededCoords) {
            if (!currentTiles.some(t => t.equals(v))) {
              _renderParcel(v.x, v.y);
            }
          }
          for (const v of currentTiles) {
            if (!neededCoords.some(t => t.equals(v))) {
              const tileId = _getTileId(v.x, v.y);
              const tileEl = document.getElementById(tileId);
              tileEl.parentNode.removeChild(tileEl);
            }
          }
          currentTiles = neededCoords;
        };
        _updateTiles();
        
        let dragSpec = null;
        container.addEventListener('mousedown', e => {
          dragSpec = {
            startPosition: _getContainerMetrics(),
            startX: e.clientX,
            startY: e.clientY,
          };
        });
        window.addEventListener('mouseup', e => {
          dragSpec = null;
          _updateTiles();
        });
        container.addEventListener('mousemove', e => {
          if (dragSpec) {
            const currentX = e.clientX;
            const currentY = e.clientY;
            const diffX = e.clientX - dragSpec.startX;
            const diffY = e.clientY - dragSpec.startY;
            const newPosition = dragSpec.startPosition.clone()
              .add(new THREE.Vector2(diffX, diffY));
            container.style.left = `${newPosition.x}px`;
            container.style.top = `${newPosition.y}px`;
          }
        });

        console.timeEnd('render');
      }, 5000);
      
      (async () => {
        const res = await fetch(`https://webaverse.github.io/parcels/parcels.json`);
        const ps = await res.json();
        for (const p of ps) {
          const {extents} = p;
          const [[x1, y1, z1], [x2, y2, z2]] = extents;
          const box = new THREE.Box3(
            new THREE.Vector3(x1, y1, z1),
            new THREE.Vector3(x2, y2, z2),
          );
          const center = box.getCenter(new THREE.Vector3());
          const div = document.createElement('a');
          div.href = `https://app.webaverse.com/?c=${JSON.stringify([center.x, center.y, center.z])}`;
          div.classList.add('parcel');
          div.innerHTML = `\
            <div class=details>${p.name}</div>
          `;
          div.addEventListener('mousedown', e => {
            e.stopPropagation();
          });
          const localWidth = (x2-x1)*width/tileScale;
          const localHeight = (z2-z1)*height/tileScale;
          div.style.left = (containerSize/2) + (x1*width/tileScale) - (perspectiveOffset.x*width/tileScale) + `px`;
          div.style.top = (containerSize/2) + (z1*height/tileScale) - (perspectiveOffset.z*height/tileScale) + `px`;
          div.style.width = localWidth + `px`;
          div.style.height = localHeight + `px`;
          container.appendChild(div);
        }
      })();
    } else {
      let {x, y, sw, sh, dw, dh} = parseQuery(location.search);

      x = parseInt(x);
      y = parseInt(y);
      sw = parseInt(sw);
      sh = parseInt(sh);
      dw = parseInt(dw);
      dh = parseInt(dh);

      orthographicCamera.left = -sw/2;
      orthographicCamera.right = sw/2;
      orthographicCamera.top = sh/2;
      orthographicCamera.bottom = -sh/2;
      orthographicCamera.near = 0;
      orthographicCamera.far = 2000;
      orthographicCamera.updateProjectionMatrix();
      camera.projectionMatrix.copy(orthographicCamera.projectionMatrix);

      cameraTarget.set(x + sw/2, 0, y + sh/2);

      const offset = new THREE.Vector3(x * tileScale, 0, y * tileScale);
      camera.position.copy(cameraPosition).add(offset);
      camera.lookAt(cameraTarget.clone().add(offset).add(new THREE.Vector3(2, 0, -5)));

      renderer.setSize(dw, dh);

      renderer.clear();
      app.render();

      container.appendChild(renderer.domElement);

      const blob = await new Promise((accept, reject) => {
        renderer.domElement.toBlob(accept);
      });

      fetch(dst, {
        method: 'POST',
        headers: {
          'Content-Type': 'image/png',
        },
        body: blob,
      }).then(res => res.blob());

      /* const arrayBuffer = await blob.arrayBuffer();
      window.parent.postMessage({
        method: 'result',
        result: arrayBuffer,
      }, '*', [arrayBuffer]); */
    }
  })();
</script>
</body>

</html>

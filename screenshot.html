<html>
<head>
  <title>Screenshotting XRPK</title>
  <link rel=stylesheet type='text/css' href="bake.css">
</head>
<body>
  <div id=baking>
    <h1>Screenshotting... Please do not close this tab!</h1>
  </div>
  <div id=baked>
    <h1>Screenshotting complete! You can close this tab.</h1>
  </div>
  <div id=error>
    <h1>There was an error screeshotting your XRPK.</h1>
    <p>
      The stack trace is below. You can close this tab.
      <br />
      <pre id=error-trace></pre>
    </p>
  </div>

  <div class=results>
    <div id=screenshot>
      <h3 id=screenshot-header></h3>
      <div id=screenshot-result></div>
    </div>
  </div>

  <script type=module>
    import * as THREE from './three.module.js';
    import {OrbitControls} from './OrbitControls.js';
    import {GLTFLoader} from './GLTFLoader.js';
    import {bake, parseQuery, toggleElements} from './bakeUtils.js';
    import {storageHost} from './constants.js';
    import './gif.js';

    const width = 512;
    const height = 512;
    const cameraPosition = new THREE.Vector3(0, 1, -2);
    const cameraTarget = new THREE.Vector3(0, 0, 0);

    const _makePromise = () => {
      let accept, reject;
      const p = new Promise((a, r) => {
        accept = a;
        reject = r;
      });
      p.accept = accept;
      p.reject = reject;
      return p;
    };

    (async () => {
      const {hash, ext, type, dst} = parseQuery(decodeURIComponent(window.location.search));

      try {
        toggleElements(false);

        const scene = new THREE.Scene();

        /* const cubeMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
          color: 0x0000FF,
        }));
        scene.add(cubeMesh); */

        const camera = new THREE.PerspectiveCamera(90, width / height, 0.1, 100);
        camera.position.copy(cameraPosition);
        camera.lookAt(cameraTarget);
        // camera.quaternion.copy(cameraQuaternion);
        // camera.lookAt(model.boundingBoxMesh.getWorldPosition(new THREE.Vector3()));
        // const localAabb = model.boundingBoxMesh.scale.clone().applyQuaternion(model.quaternion);
        // const modelHeight = Math.max(model.boundingBoxMesh.scale.x, model.boundingBoxMesh.scale.y, model.boundingBoxMesh.scale.z);
        // camera.fov = 2 * Math.atan( modelHeight / ( 2 * dist ) ) * ( 180 / Math.PI );
        // camera.updateProjectionMatrix();

        // camera.lookAt(model.boundingBoxMesh.getWorldPosition(new THREE.Vector3()));

       const renderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true,
        });
        renderer.setSize(width, height);

        const screenshotResult = document.getElementById('screenshot-result');

        if (type === 'gltf') {
          const {model, arrayBuffer, file} = await bake(hash, ext, dst);
          scene.add(model);

          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.render(scene, camera);

          screenshotResult.appendChild(renderer.domElement);

          renderer.domElement.style.background = '#F00';

          const orbitControls = new OrbitControls(camera, renderer.domElement, document);
          orbitControls.screenSpacePanning = true;
          orbitControls.enableMiddleZoom = false;
          orbitControls.target.copy(cameraTarget);
          orbitControls.update();

          renderer.setAnimationLoop(() => {
            orbitControls.update();

            renderer.render(scene, camera);
          });

          if (dst) {
            fetch(dst, {
              method: 'POST',
              headers: {
                'Content-Type': 'model/gltf-binary',
              },
              body: arrayBuffer,
            }).then(res => res.blob());
          }

          window.parent.postMessage({
            method: 'result',
            result: arrayBuffer,
          }, '*', [arrayBuffer]);
        } else if (type === 'png' || type === 'jpg') {
          const u = `${storageHost}/${hash}`;
          let o;
          try {
            o = await new Promise((accept, reject) => {
              new GLTFLoader().load(u, accept, function onprogress() {}, reject);
            });
          } catch(err) {
            console.warn(err);
          } /* finally {
            URL.revokeObjectURL(u);
          } */
          o = o.scene;
          scene.add(o);

          if (type === 'jpg') {
            renderer.setClearColor(0xFFFFFF, 1);
          }
          renderer.render(scene, camera);

          const mimeType = `image/${type === 'png' ? 'png' : 'jpeg'}`;
          const blob = await new Promise((accept, reject) => {
            renderer.domElement.toBlob(accept, mimeType);
          });
          const img = new Image();
          await new Promise((accept, reject) => {
            img.onload = accept;
            img.onerror = reject;
            img.src = URL.createObjectURL(blob);
          });
          img.style.width = `${img.width/window.devicePixelRatio}px`;
          img.style.height = `${img.height/window.devicePixelRatio}px`;
          screenshotResult.appendChild(img);

          const arrayBuffer = await blob.arrayBuffer();

          // console.log('png blob arrayBuffer', blob.size, arrayBuffer.byteLength);

          if (dst) {
            fetch(dst, {
              method: 'POST',
              headers: {
                'Content-Type': mimeType,
              },
              body: arrayBuffer,
            }).then(res => res.blob());
          }

          window.parent.postMessage({
            method: 'result',
            result: arrayBuffer,
          }, '*', [arrayBuffer]);
        } else if (type === 'gif') {
          const u = `${storageHost}/${hash}`;
          let o;
          try {
            o = await new Promise((accept, reject) => {
              new GLTFLoader().load(u, accept, function onprogress() {}, reject);
            });
          } catch(err) {
            console.warn(err);
          } /* finally {
            URL.revokeObjectURL(u);
          } */
          o = o.scene;
          scene.add(o);

          const boundingBox = new THREE.Box3().setFromObject(o);
          const center = boundingBox.getCenter(new THREE.Vector3());
          const size = boundingBox.getSize(new THREE.Vector3());

          renderer.setClearColor(0xFFFFFF, 1);

          const gif = new GIF({
            workers: 2,
            quality: 10,
          });
          for (let i = 0; i < Math.PI * 2; i += Math.PI * 0.05) {
            camera.position.copy(center)
              .add(new THREE.Vector3(0, size.y / 2, 0))
              .add(new THREE.Vector3(Math.cos(i + Math.PI / 2), 0, Math.sin(i + Math.PI / 2)).multiplyScalar(Math.max(size.x, size.z) * 1.2));
            camera.lookAt(center);
            camera.updateMatrixWorld();
            renderer.render(scene, camera);

            // read
            const writeCanvas = document.createElement('canvas');
            writeCanvas.width = width;
            writeCanvas.height = height;
            // draw
            const writeCtx = writeCanvas.getContext('2d');
            writeCtx.drawImage(renderer.domElement, 0, 0);
            /* // flip
            writeCtx.globalCompositeOperation = 'copy';
            writeCtx.scale(1, -1);
            writeCtx.translate(0, -writeCanvas.height);
            writeCtx.drawImage(writeCanvas, 0, 0); */

            gif.addFrame(writeCanvas, {delay: 50});
          }
          gif.render();

          const blob = await new Promise((resolve, reject) => {
            gif.on('finished', resolve);
          });

          const img = new Image();
          await new Promise((accept, reject) => {
            img.onload = accept;
            img.onerror = reject;
            img.src = URL.createObjectURL(blob);
          });
          img.style.width = `${width}px`;
          img.style.height = `${height}px`;
          screenshotResult.appendChild(img);

          const arrayBuffer = await blob.arrayBuffer();

          if (dst) {
            fetch(dst, {
              method: 'POST',
              headers: {
                'Content-Type': 'image/gif',
              },
              body: arrayBuffer,
            }).then(res => res.blob());
          }

          window.parent.postMessage({
            method: 'result',
            result: arrayBuffer,
          }, '*', [arrayBuffer]);
        } else if (type === 'webm') {
          const u = `${storageHost}/${hash}`;
          let o;
          try {
            o = await new Promise((accept, reject) => {
              new GLTFLoader().load(u, accept, function onprogress() {}, reject);
            });
          } catch(err) {
            console.warn(err);
          } /* finally {
            URL.revokeObjectURL(u);
          } */
          o = o.scene;
          scene.add(o);

          const stream = renderer.domElement.captureStream(0);
          const track = stream.getVideoTracks()[0];
          const recordedChunks = [];

          // renderer.getContext();
          // screenshotResult.appendChild(renderer.domElement);
          const mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'video/webm; codecs=vp9',
          });

          mediaRecorder.ondataavailable = event => {
            // console.log('got data', event.data);
            if (event.data.size > 0) {
              recordedChunks.push(event.data);
              // console.log(recordedChunks);
              // download();
            } else {
              // ...
            }
          };
          const p = _makePromise();
          mediaRecorder.onstop = () => {
            // console.log('done');
            p.accept();
          };
          mediaRecorder.start();

          const boundingBox = new THREE.Box3().setFromObject(o);
          const center = boundingBox.getCenter(new THREE.Vector3());
          const size = boundingBox.getSize(new THREE.Vector3());

          renderer.setClearColor(0xFFFFFF, 1);

          for (let i = 0; i < Math.PI * 2; i += Math.PI * 0.02) {
            await new Promise((accept, reject) => {
              requestAnimationFrame(accept);
            });
            camera.position.copy(center)
              .add(new THREE.Vector3(0, size.y / 2, 0))
              .add(new THREE.Vector3(Math.cos(i + Math.PI / 2), 0, Math.sin(i + Math.PI / 2)).multiplyScalar(Math.max(size.x, size.z) * 1.2));
            camera.lookAt(center);
            camera.updateMatrixWorld();
            renderer.render(scene, camera);

            track.requestFrame();
            mediaRecorder.requestData();
          }
          mediaRecorder.stop();

          await p;

          const blob = new Blob(recordedChunks, {
            type: 'video/webm',
          });

          const video = document.createElement('video');
          video.muted = true;
          video.autoplay = true;
          await new Promise((accept, reject) => {
            video.oncanplaythrough = accept;
            video.onerror = reject;
            video.src = URL.createObjectURL(blob);
          });
          video.style.width = `${width}px`;
          video.style.height = `${height}px`;
          video.loop = true;
          screenshotResult.appendChild(video);

          const arrayBuffer = await blob.arrayBuffer();

          if (dst) {
            fetch(dst, {
              method: 'POST',
              headers: {
                'Content-Type': 'image/gif',
              },
              body: arrayBuffer,
            }).then(res => res.blob());
          }

          window.parent.postMessage({
            method: 'result',
            result: arrayBuffer,
          }, '*', [arrayBuffer]);
        } else {
          console.warn('unknown output type', type);
        }

        toggleElements(true);
      } catch (err) {
        toggleElements(null, err);
        console.warn(err.stack);

        if (dst) {
          fetch(dst, {
            method: 'POST',
            headers: {
              'Content-Type': 'text/plain',
            },
            body: err.stack,
          }).then(res => res.blob());
        }

        window.parent.postMessage({
          method: 'error',
          error: err.stack,
        }, '*');
      }
    })();
  </script>
</body>

</html>

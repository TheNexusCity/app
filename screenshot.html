<html>
<head>
  <title>Screenshotting XRPK</title>
  <link rel=stylesheet type='text/css' href="bake.css">
</head>
<body>
  <div id=baking>
    <h1>Screenshotting... Please do not close this tab!</h1>
  </div>
  <div id=baked>
    <h1>Screenshotting complete! You can close this tab.</h1>
  </div>
  <div id=error>
    <h1>There was an error screeshotting your XRPK.</h1>
    <p>
      The stack trace is below. You can close this tab.
      <br />
      <pre id=error-trace></pre>
    </p>
  </div>

  <div class=results>
    <div id=screenshot>
      <h3 id=screenshot-header></h3>
      <div id=screenshot-result></div>
    </div>
  </div>

  <script type=module>
    import * as THREE from './three.module.js';
    import {OrbitControls} from './OrbitControls.js';
    import {GLTFLoader} from './GLTFLoader.js';
    import {bake, parseQuery, toggleElements} from './bakeUtils.js';
    import {storageHost} from './constants.js';
    import './gif.js';

    const width = 512;
    const height = 512;
    const cameraPosition = new THREE.Vector3(0, 1, -2);
    const cameraTarget = new THREE.Vector3(0, 0, 0);

    const _makePromise = () => {
      let accept, reject;
      const p = new Promise((a, r) => {
        accept = a;
        reject = r;
      });
      p.accept = accept;
      p.reject = reject;
      return p;
    };

    (async () => {
      const {hash, ext, type, dst} = parseQuery(decodeURIComponent(window.location.search));

      try {
        toggleElements(false);

        const scene = new THREE.Scene();

        /* const cubeMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
          color: 0x0000FF,
        }));
        scene.add(cubeMesh); */

        const camera = new THREE.PerspectiveCamera(90, width / height, 0.1, 100);
        camera.position.copy(cameraPosition);
        camera.lookAt(cameraTarget);
        // camera.quaternion.copy(cameraQuaternion);
        // camera.lookAt(model.boundingBoxMesh.getWorldPosition(new THREE.Vector3()));
        // const localAabb = model.boundingBoxMesh.scale.clone().applyQuaternion(model.quaternion);
        // const modelHeight = Math.max(model.boundingBoxMesh.scale.x, model.boundingBoxMesh.scale.y, model.boundingBoxMesh.scale.z);
        // camera.fov = 2 * Math.atan( modelHeight / ( 2 * dist ) ) * ( 180 / Math.PI );
        // camera.updateProjectionMatrix();

        // camera.lookAt(model.boundingBoxMesh.getWorldPosition(new THREE.Vector3()));

       const renderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true,
        });
        renderer.setSize(width, height);

        const screenshotResult = document.getElementById('screenshot-result');

        if (type === 'gltf') {
          const {model, arrayBuffer, file} = await bake(hash, ext, dst);
          scene.add(model);

          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.render(scene, camera);

          screenshotResult.appendChild(renderer.domElement);

          renderer.domElement.style.background = '#F00';

          const orbitControls = new OrbitControls(camera, renderer.domElement, document);
          orbitControls.screenSpacePanning = true;
          orbitControls.enableMiddleZoom = false;
          orbitControls.target.copy(cameraTarget);
          orbitControls.update();

          renderer.setAnimationLoop(() => {
            orbitControls.update();

            renderer.render(scene, camera);
          });

          if (dst) {
            fetch(dst, {
              method: 'POST',
              headers: {
                'Content-Type': 'model/gltf-binary',
              },
              body: arrayBuffer,
            }).then(res => res.blob());
          }

          window.parent.postMessage({
            method: 'result',
            result: arrayBuffer,
          }, '*', [arrayBuffer]);
        } else if (type === 'png' || type === 'jpg') {
          const u = `${storageHost}/${hash}`;
          let o;
          try {
            o = await new Promise((accept, reject) => {
              new GLTFLoader().load(u, accept, function onprogress() {}, reject);
            });
          } catch(err) {
            console.warn(err);
          } /* finally {
            URL.revokeObjectURL(u);
          } */
          o = o.scene;
          scene.add(o);

          const boundingBox = new THREE.Box3().setFromObject(o);
          const center = boundingBox.getCenter(new THREE.Vector3());
          const size = boundingBox.getSize(new THREE.Vector3());

          camera.position.x = 0;
          camera.position.y = center.y;
          camera.position.z = -size.y / 2 / Math.tan(Math.PI * camera.fov / 360) * 1.2;
          camera.lookAt(center);
          camera.updateMatrixWorld();

          if (ext === 'vrm') {
            const _getTailBones = skeleton => {
              const result = [];
              const _recurse = bones => {
                for (let i = 0; i < bones.length; i++) {
                  const bone = bones[i];
                  if (bone.children.length === 0) {
                    if (!result.includes(bone)) {
                      result.push(bone);
                    }
                  } else {
                    _recurse(bone.children);
                  }
                }
              };
              _recurse(skeleton.bones);
              return result;
            };
            const _findFurthestParentBone = (bone, pred) => {
              let result = null;
              for (; bone; bone = bone.parent) {
                if (pred(bone)) {
                  result = bone;
                }
              }
              return result;
            };
            const _countCharacters = (name, regex) => {
              let result = 0;
              for (let i = 0; i < name.length; i++) {
                if (regex.test(name[i])) {
                  result++;
                }
              }
              return result;
            };
            const _findEye = (tailBones, left) => {
              const regexp = left ? /l/i : /r/i;
              const eyeBones = tailBones.map(tailBone => {
                const eyeBone = _findFurthestParentBone(tailBone, bone => /eye/i.test(bone.name) && regexp.test(bone.name.replace(/eye/gi, '')));
                if (eyeBone) {
                  return eyeBone;
                } else {
                  return null;
                }
              }).filter(spec => spec).sort((a, b) => {
                const aName = a.name.replace(/shoulder/gi, '');
                const aLeftBalance = _countCharacters(aName, /l/i) - _countCharacters(aName, /r/i);
                const bName = b.name.replace(/shoulder/gi, '');
                const bLeftBalance = _countCharacters(bName, /l/i) - _countCharacters(bName, /r/i);
                if (!left) {
                  return aLeftBalance - bLeftBalance;
                } else {
                  return bLeftBalance - aLeftBalance;
                }
              });
              const eyeBone = eyeBones.length > 0 ? eyeBones[0] : null;
              if (eyeBone) {
                return eyeBone;
              } else {
                return null;
              }
            };

            const skinnedMeshes = [];
            o.traverse(o => {
              if (o.isSkinnedMesh) {
                skinnedMeshes.push(o);
              }
            });
            skinnedMeshes.sort((a, b) => b.skeleton.bones.length - a.skeleton.bones.length);
            const skeletonSkinnedMesh = skinnedMeshes.find(o => o.skeleton.bones[0].parent) || null;
            const skeleton = skeletonSkinnedMesh && skeletonSkinnedMesh.skeleton;
            const tailBones = _getTailBones(skeleton);
            const eyes = [_findEye(tailBones, true), _findEye(tailBones, false)];
            if (eyes[0] && eyes[1]) {
              const center = eyes[0].getWorldPosition(new THREE.Vector3())
                .add(eyes[1].getWorldPosition(new THREE.Vector3()))
                .divideScalar(2);
              camera.position.copy(center)
                .add(new THREE.Vector3(0, 0, -0.3));
              camera.fov = 60;
              camera.updateProjectionMatrix();
            }
            console.log('got eyes', eyes);
          }

          if (type === 'jpg') {
            renderer.setClearColor(0xFFFFFF, 1);
          }
          renderer.render(scene, camera);

          const mimeType = `image/${type === 'png' ? 'png' : 'jpeg'}`;
          const blob = await new Promise((accept, reject) => {
            renderer.domElement.toBlob(accept, mimeType);
          });
          const img = new Image();
          await new Promise((accept, reject) => {
            img.onload = accept;
            img.onerror = reject;
            img.src = URL.createObjectURL(blob);
          });
          img.style.width = `${img.width/window.devicePixelRatio}px`;
          img.style.height = `${img.height/window.devicePixelRatio}px`;
          screenshotResult.appendChild(img);

          const arrayBuffer = await blob.arrayBuffer();

          // console.log('png blob arrayBuffer', blob.size, arrayBuffer.byteLength);

          if (dst) {
            fetch(dst, {
              method: 'POST',
              headers: {
                'Content-Type': mimeType,
              },
              body: arrayBuffer,
            }).then(res => res.blob());
          }

          window.parent.postMessage({
            method: 'result',
            result: arrayBuffer,
          }, '*', [arrayBuffer]);
        } else if (type === 'gif') {
          const u = `${storageHost}/${hash}`;
          let o;
          try {
            o = await new Promise((accept, reject) => {
              new GLTFLoader().load(u, accept, function onprogress() {}, reject);
            });
          } catch(err) {
            console.warn(err);
          } /* finally {
            URL.revokeObjectURL(u);
          } */
          o = o.scene;
          scene.add(o);

          const boundingBox = new THREE.Box3().setFromObject(o);
          const center = boundingBox.getCenter(new THREE.Vector3());
          const size = boundingBox.getSize(new THREE.Vector3());

          renderer.setClearColor(0xFFFFFF, 1);

          const gif = new GIF({
            workers: 4,
            quality: 10,
          });
          for (let i = 0; i < Math.PI * 2; i += Math.PI * 0.05) {
            camera.position.copy(center)
              .add(new THREE.Vector3(0, size.y / 2, 0))
              .add(new THREE.Vector3(Math.cos(i + Math.PI / 2), 0, Math.sin(i + Math.PI / 2)).multiplyScalar(Math.max(size.x, size.z) * 1.2));
            camera.lookAt(center);
            camera.updateMatrixWorld();
            renderer.render(scene, camera);

            // read
            const writeCanvas = document.createElement('canvas');
            writeCanvas.width = width;
            writeCanvas.height = height;
            // draw
            const writeCtx = writeCanvas.getContext('2d');
            writeCtx.drawImage(renderer.domElement, 0, 0);
            /* // flip
            writeCtx.globalCompositeOperation = 'copy';
            writeCtx.scale(1, -1);
            writeCtx.translate(0, -writeCanvas.height);
            writeCtx.drawImage(writeCanvas, 0, 0); */

            gif.addFrame(writeCanvas, {delay: 50});
          }
          gif.render();

          const blob = await new Promise((resolve, reject) => {
            gif.on('finished', resolve);
          });

          const img = new Image();
          await new Promise((accept, reject) => {
            img.onload = accept;
            img.onerror = reject;
            img.src = URL.createObjectURL(blob);
          });
          img.style.width = `${width}px`;
          img.style.height = `${height}px`;
          screenshotResult.appendChild(img);

          const arrayBuffer = await blob.arrayBuffer();

          if (dst) {
            fetch(dst, {
              method: 'POST',
              headers: {
                'Content-Type': 'image/gif',
              },
              body: arrayBuffer,
            }).then(res => res.blob());
          }

          window.parent.postMessage({
            method: 'result',
            result: arrayBuffer,
          }, '*', [arrayBuffer]);
        } else if (type === 'webm') {
          const u = `${storageHost}/${hash}`;
          let o;
          try {
            o = await new Promise((accept, reject) => {
              new GLTFLoader().load(u, accept, function onprogress() {}, reject);
            });
          } catch(err) {
            console.warn(err);
          } /* finally {
            URL.revokeObjectURL(u);
          } */
          o = o.scene;
          scene.add(o);

          const boundingBox = new THREE.Box3().setFromObject(o);
          const center = boundingBox.getCenter(new THREE.Vector3());
          const size = boundingBox.getSize(new THREE.Vector3());

          renderer.setClearColor(0xFFFFFF, 1);

          const frames = [];
          for (let i = 0; i < Math.PI * 2; i += Math.PI * 0.02) {
            camera.position.copy(center)
              .add(new THREE.Vector3(0, size.y / 2, 0))
              .add(new THREE.Vector3(Math.cos(i + Math.PI / 2), 0, Math.sin(i + Math.PI / 2)).multiplyScalar(Math.max(size.x, size.z) * 1.2));
            camera.lookAt(center);
            camera.updateMatrixWorld();
            renderer.render(scene, camera);

            const writeCanvas = document.createElement('canvas');
            writeCanvas.width = width;
            writeCanvas.height = height;
            // draw
            const writeCtx = writeCanvas.getContext('2d');
            writeCtx.drawImage(renderer.domElement, 0, 0);

            frames.push(writeCanvas);
          }

          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          const stream = canvas.captureStream(0);
          const track = stream.getVideoTracks()[0];
          const recordedChunks = [];

          const mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'video/webm; codecs=vp9',
          });

          mediaRecorder.ondataavailable = event => {
            // console.log('got data', event.data);
            if (event.data.size > 0) {
              recordedChunks.push(event.data);
              // console.log(recordedChunks);
              // download();
            } else {
              // ...
            }
          };
          const p = _makePromise();
          mediaRecorder.onstop = () => {
            // console.log('stop');
            p.accept();
          };
          mediaRecorder.start();
          for (const frame of frames) {
            ctx.drawImage(frame, 0, 0);
            track.requestFrame();
            await new Promise((accept, reject) => {
              setTimeout(accept, 1000/60);
            });
          }
          mediaRecorder.stop();

          await p;

          const blob = new Blob(recordedChunks, {
            type: 'video/webm',
          });

          const video = document.createElement('video');
          video.muted = true;
          video.autoplay = true;
          await new Promise((accept, reject) => {
            video.oncanplaythrough = accept;
            video.onerror = reject;
            video.src = URL.createObjectURL(blob);
          });
          video.style.width = `${width}px`;
          video.style.height = `${height}px`;
          video.loop = true;
          screenshotResult.appendChild(video);

          const arrayBuffer = await blob.arrayBuffer();

          if (dst) {
            fetch(dst, {
              method: 'POST',
              headers: {
                'Content-Type': 'video/webm',
              },
              body: arrayBuffer,
            }).then(res => res.blob());
          }

          window.parent.postMessage({
            method: 'result',
            result: arrayBuffer,
          }, '*', [arrayBuffer]);
        } else {
          console.warn('unknown output type', type);
        }

        toggleElements(true);
      } catch (err) {
        toggleElements(null, err);
        console.warn(err.stack);

        if (dst) {
          fetch(dst, {
            method: 'POST',
            headers: {
              'Content-Type': 'text/plain',
            },
            body: err.stack,
          }).then(res => res.blob());
        }

        window.parent.postMessage({
          method: 'error',
          error: err.stack,
        }, '*');
      }
    })();
  </script>
</body>

</html>

<!doctype html>
<html>
<body>
  <form id=split-form>
    <h1>Split mesh</h1>
    <input type=number value=100 id=split-size>
    <input type=file id=split-file>
    <input type=submit>
  </form>
  <form id=bake-form>
    <h1>Bake physics</h1>
    <input type=file id=bake-file>
    <input type=submit>
  </form>
<script src="./bin/geometry.js"></script>
<script type=module>
import * as THREE from './three.module.js';
import {GLTFLoader} from './GLTFLoader.js';
import {GLTFExporter} from './GLTFExporter.js';
import {makePromise, downloadFile} from './util.js';

const localVector = new THREE.Vector3();
const localVector2 = new THREE.Vector3();
const localVector3 = new THREE.Vector3();
const localVector4 = new THREE.Vector3();
const localTriangle = new THREE.Triangle();

const splitFormEl = document.getElementById('split-form');
const splitSizeEl = document.getElementById('split-size');
const splitFileEl = document.getElementById('split-file');
splitFormEl.addEventListener('submit', async e => {
  e.preventDefault();
  e.stopPropagation();

  const [file] = splitFileEl.files;
  if (file) {
    let o = await new Promise((accept, reject) => {
      const u = URL.createObjectURL(file);
      new GLTFLoader().load(u, accept, function onprogress() {}, reject);
    });
    o = o.scene;
    let mesh = null;
    o.traverse(o => {
      if (!mesh && o.isMesh) {
        mesh = o;
      }
    });
    const geometries = [];
    const parcelSize = parseInt(splitSizeEl.value, 10);
    const _getGeometry = p => {
      let g = geometries.find(g => g.boundingBox.containsPoint(p));
      if (!g) {
        g = new THREE.BufferGeometry();
        const positions = new Float32Array(1024 * 1024 * 8);
        const normals = new Float32Array(1024 * 1024 * 8);
        
        const minX = Math.floor(p.x/parcelSize)*parcelSize;
        const minZ = Math.floor(p.z/parcelSize)*parcelSize;
        g.boundingBox = new THREE.Box3(
          new THREE.Vector3(minX, -Infinity, minZ),
          new THREE.Vector3(minX + parcelSize, Infinity, minZ + parcelSize),
        );
        g.boundingSphere = new THREE.Sphere(g.boundingBox.min.clone().add(g.boundingBox.max).divideScalar(2), Math.sqrt((parcelSize**2)*3));
        let positionIndex = 0;
        g.addPoint = (p, n) => {
          p.toArray(positions, positionIndex);
          n.toArray(normals, positionIndex);
          positionIndex += 3;
          if (positionIndex > positions.length) {
            debugger;
          }
        };
        g.finalize = () => {
          g.setAttribute('position', new THREE.BufferAttribute(positions.slice(0, positionIndex), 3));
          g.setAttribute('normal', new THREE.BufferAttribute(normals.slice(0, positionIndex), 3));
        };
        geometries.push(g);
      }
      return g;
    };
    mesh.updateMatrixWorld();
    const {geometry} = mesh;
    for (let i = 0; i < geometry.index.array.length; i += 3) {
      const a = geometry.index.array[i];
      const b = geometry.index.array[i+1];
      const c = geometry.index.array[i+2];
      const center = localTriangle.set(
        localVector.fromArray(geometry.attributes.position.array, a*3).applyMatrix4(mesh.matrixWorld),
        localVector2.fromArray(geometry.attributes.position.array, b*3).applyMatrix4(mesh.matrixWorld),
        localVector3.fromArray(geometry.attributes.position.array, c*3).applyMatrix4(mesh.matrixWorld),
      ).getMidpoint(localVector4);
      localVector.fromArray(geometry.attributes.normal.array, a*3).applyQuaternion(mesh.quaternion);
      localVector2.fromArray(geometry.attributes.normal.array, b*3).applyQuaternion(mesh.quaternion);
      localVector3.fromArray(geometry.attributes.normal.array, c*3).applyQuaternion(mesh.quaternion);
      const g = _getGeometry(center);
      g.addPoint(localTriangle.a, localVector);
      g.addPoint(localTriangle.b, localVector2);
      g.addPoint(localTriangle.c, localVector3);
    }
    const meshes = geometries.map(geometry => {
      geometry.finalize();
      return new THREE.Mesh(geometry, mesh.material);
    });

    const newMesh = new THREE.Scene();
    for (const child of meshes) {
      newMesh.add(child);
    }
    const data = await new Promise((accept, reject) => {
      new GLTFExporter().parse(newMesh, accept, {
        binary: true,
        includeCustomExtensions: true,
      });
    });
    const b = new Blob([data], {
      type: 'application/octet-stream',
    });
    downloadFile(b, 'target.glb');
  }
});

const bakeFormEl = document.getElementById('bake-form');
const bakeFileEl = document.getElementById('bake-file');
bakeFormEl.addEventListener('submit', async e => {
  e.preventDefault();
  e.stopPropagation();

  const [file] = bakeFileEl.files;
  if (file) {
    const geometryWorker = (() => {  
      class Allocator {
        constructor() {
          this.offsets = [];
        }

        alloc(constructor, size) {
          if (size > 0) {
            const offset = moduleInstance._malloc(size * constructor.BYTES_PER_ELEMENT);
            const b = new constructor(moduleInstance.HEAP8.buffer, moduleInstance.HEAP8.byteOffset + offset, size);
            b.offset = offset;
            this.offsets.push(offset);
            return b;
          } else {
            return new constructor(moduleInstance.HEAP8.buffer, 0, 0);
          }
        }

        freeAll() {
          for (let i = 0; i < this.offsets.length; i++) {
            moduleInstance._doFree(this.offsets[i]);
          }
          this.offsets.length = 0;
        }
      }

      const maxNumMessageArgs = 32;
      const messageSize =
        Int32Array.BYTES_PER_ELEMENT + // id
        Int32Array.BYTES_PER_ELEMENT + // method
        Int32Array.BYTES_PER_ELEMENT + // priority
        maxNumMessageArgs*Uint32Array.BYTES_PER_ELEMENT; // args
      const maxNumMessages = 1024;
      const callStackSize = maxNumMessages * messageSize;
      class CallStackMessage {
        constructor(ptr) {
          this.dataView = new DataView(moduleInstance.HEAP8.buffer, ptr, messageSize);
          this.offset = 3*Uint32Array.BYTES_PER_ELEMENT;
        }
        getId() {
          return this.dataView.getInt32(0, true);
        }
        getMethod() {
          return this.dataView.getInt32(Uint32Array.BYTES_PER_ELEMENT, true);
        }
        getPriority() {
          return this.dataView.getInt32(2*Uint32Array.BYTES_PER_ELEMENT, true);
        }
        setId(v) {
          this.dataView.setInt32(0, v, true);
        }
        setMethod(v) {
          this.dataView.setInt32(Uint32Array.BYTES_PER_ELEMENT, v, true);
        }
        setPriority(v) {
          this.dataView.setInt32(2*Uint32Array.BYTES_PER_ELEMENT, v, true);
        }
        pullU8Array(length) {
          const {offset} = this;
          this.offset += length;
          return new Uint8Array(this.dataView.buffer, this.dataView.byteOffset + offset, length);;
        }
        pullF32Array(length) {
          const {offset} = this;
          this.offset += length*Float32Array.BYTES_PER_ELEMENT;
          return new Float32Array(this.dataView.buffer, this.dataView.byteOffset + offset, length);
        }
        pullI32() {
          const {offset} = this;
          this.offset += Int32Array.BYTES_PER_ELEMENT;
          return this.dataView.getInt32(offset, true);;
        }
        pullU32() {
          const {offset} = this;
          this.offset += Uint32Array.BYTES_PER_ELEMENT;
          return this.dataView.getUint32(offset, true);;
        }
        pullF32() {
          const {offset} = this;
          this.offset += Float32Array.BYTES_PER_ELEMENT;
          return this.dataView.getFloat32(offset, true);
        }
        pushU8Array(uint8Array) {
          new Uint8Array(this.dataView.buffer, this.dataView.byteOffset + this.offset, uint8Array.length).set(uint8Array);
          this.offset += uint8Array.byteLength;
        }
        pushF32Array(float32Array) {
          new Float32Array(this.dataView.buffer, this.dataView.byteOffset + this.offset, float32Array.length).set(float32Array);
          this.offset += float32Array.byteLength;
        }
        pushI32(v) {
          this.dataView.setInt32(this.offset, v, true);
          this.offset += Int32Array.BYTES_PER_ELEMENT;
        }
        pushU32(v) {
          this.dataView.setUint32(this.offset, v, true);
          this.offset += Uint32Array.BYTES_PER_ELEMENT;
        }
        pushF32(v) {
          this.dataView.setFloat32(this.offset, v, true);
          this.offset += Float32Array.BYTES_PER_ELEMENT;
        }
        /* pullU8Array(length) {
          if (this.offset + length <= messageSize) {
            const result = new Uint8Array(this.dataView.buffer, this.dataView.byteOffset + this.offset, length);
            this.offset += length;
            return result;
          } else {
            throw new Error('message overflow');
          }
        }
        pullF32Array(length) {
          if (this.offset + length*Float32Array.BYTES_PER_ELEMENT <= messageSize) {
            const result = new Float32Array(this.dataView.buffer, this.dataView.byteOffset + this.offset, length);
            this.offset += length*Float32Array.BYTES_PER_ELEMENT;
            return result;
          } else {
            throw new Error('message overflow');
          }
        }
        pullI32() {
          if (this.offset + Int32Array.BYTES_PER_ELEMENT <= messageSize) {
            const result = this.dataView.getInt32(this.offset, true);
            this.offset += Int32Array.BYTES_PER_ELEMENT;
            return result;
          } else {
            throw new Error('message overflow');
          }
        }
        pullU32() {
          if (this.offset + Uint32Array.BYTES_PER_ELEMENT <= messageSize) {
            const result = this.dataView.getUint32(this.offset, true);
            this.offset += Uint32Array.BYTES_PER_ELEMENT;
            return result;
          } else {
            throw new Error('message overflow');
          }
        }
        pullF32() {
          if (this.offset + Float32Array.BYTES_PER_ELEMENT <= messageSize) {
            const result = this.dataView.getFloat32(this.offset, true);
            this.offset += Float32Array.BYTES_PER_ELEMENT;
            return result;
          } else {
            throw new Error('message overflow');
          }
        }
        pushU8Array(uint8Array) {
          if (this.offset + uint8Array.byteLength <= messageSize) {
            new Uint8Array(this.dataView.buffer, this.dataView.byteOffset + this.offset, uint8Array.length).set(uint8Array);
            this.offset += uint8Array.byteLength;
          } else {
            throw new Error('message overflow');
          }
        }
        pushF32Array(float32Array) {
          if (this.offset + float32Array.byteLength <= messageSize) {
            new Float32Array(this.dataView.buffer, this.dataView.byteOffset + this.offset, float32Array.length).set(float32Array);
            this.offset += float32Array.byteLength;
          } else {
            throw new Error('message overflow');
          }
        }
        pushI32(v) {
          if (this.offset + Int32Array.BYTES_PER_ELEMENT <= messageSize) {
            this.dataView.setInt32(this.offset, v, true);
            this.offset += Int32Array.BYTES_PER_ELEMENT;
          } else {
            throw new Error('message overflow');
          }
        }
        pushU32(v) {
          if (this.offset + Uint32Array.BYTES_PER_ELEMENT <= messageSize) {
            this.dataView.setUint32(this.offset, v, true);
            this.offset += Uint32Array.BYTES_PER_ELEMENT;
          } else {
            throw new Error('message overflow');
          }
        }
        pushF32(v) {
          if (this.offset + Float32Array.BYTES_PER_ELEMENT <= messageSize) {
            this.dataView.setFloat32(this.offset, v, true);
            this.offset += Float32Array.BYTES_PER_ELEMENT;
          } else {
            throw new Error('message overflow');
          }
        } */
      }
      class CallStack {
        constructor() {
          this.ptr = moduleInstance._malloc(callStackSize * 2 + Uint32Array.BYTES_PER_ELEMENT);
          this.dataView = new DataView(moduleInstance.HEAP8.buffer, this.ptr, callStackSize);

          this.outPtr = this.ptr + callStackSize;
          this.outDataView = new DataView(moduleInstance.HEAP8.buffer, this.ptr + callStackSize, callStackSize);

          this.outNumEntriesPtr = this.ptr + callStackSize * 2;
          this.outNumEntriesU32 = new Uint32Array(moduleInstance.HEAP8.buffer, this.outNumEntriesPtr, 1);

          this.numEntries = 0;
          this.nextCbId = 0;
        }

        allocRequest(method, prio, startCb, endCb) {
          const index = this.numEntries++;
          const offset = index * messageSize;
          const startMessage = new CallStackMessage(this.ptr + offset);

          const id = ++this.nextCbId;
          startMessage.setId(id);
          startMessage.setMethod(method);
          startMessage.setPriority(+prio);
          
          startCb(startMessage);
          cbIndex.set(id, endCb);
        }

        reset() {
          this.numEntries = 0;
        }
      }
      class ScratchStack {
        constructor() {
          const size = 1024*1024;
          this.ptr = moduleInstance._malloc(size);

          this.u8 = new Uint8Array(moduleInstance.HEAP8.buffer, this.ptr, size);
          this.u32 = new Uint32Array(moduleInstance.HEAP8.buffer, this.ptr, size/4);
          this.i32 = new Int32Array(moduleInstance.HEAP8.buffer, this.ptr, size/4);
          this.f32 = new Float32Array(moduleInstance.HEAP8.buffer, this.ptr, size/4);
        }
      }
      
      const modulePromise = makePromise();
      /* const INITIAL_INITIAL_MEMORY = 52428800;
      const WASM_PAGE_SIZE = 65536;
      const wasmMemory = new WebAssembly.Memory({
        "initial": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,
        "maximum": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,
        "shared": true,
      }); */
      let localModuleInstance = null;
      let moduleInstance = null;
      let threadPool;
      let callStack;
      let scratchStack;
      // GeometryModule({
        // ENVIRONMENT_IS_PTHREAD: true,
        // wasmMemory,
        // buffer: wasmMemory.buffer,
        // noInitialRun: true,
        // noExitRuntime: true,
        Module.onRuntimeInitialized = function() {
          localModuleInstance = this;
        };
        Module.postRun = () => {
          moduleInstance = localModuleInstance;
          // moduleInstance._globalInit();
          // callStack = new CallStack();
          scratchStack = new ScratchStack();
          // threadPool = moduleInstance._makeThreadPool(1);
          // threadPool = moduleInstance._getThreadPool();
          modulePromise.accept();
        };
        if (Module.calledRun) {
          Module.onRuntimeInitialized();
          Module.postRun();
        }
      // });

      let methodIndex = 0;
      const cbIndex = new Map();
      const w = {};
      /* window.earcut = () => {
        const positionsData = Float32Array.from([
          0, 0, 0, 100, 100, 100, 100, 0,
        ]);
        for (let i = 0; i < positionsData.length; i++) {
          positionsData[i] /= 30;
        }
        const positions = w.alloc(Float32Array, positionsData.length);
        positions.set(positionsData);

        const holesData = Float32Array.from([
          75, 25, 75, 75, 25, 75, 25, 25,
        ]);
        for (let i = 0; i < holesData.length; i++) {
          holesData[i] /= 30;
        }
        const holes = w.alloc(Float32Array, holesData.length);
        holes.set(holesData);

        const holeCountsData = Uint32Array.from([
          4,
        ]);
        const holeCounts = w.alloc(Uint32Array, holeCountsData.length);
        holeCounts.set(holeCountsData);

        const pointsData = Float32Array.from([
          10, 10,
        ]);
        for (let i = 0; i < pointsData.length; i++) {
          pointsData[i] /= 30;
        }
        const points = w.alloc(Float32Array, pointsData.length);
        points.set(pointsData);

        const zData = Float32Array.from([
          0, 30, 10, 0,
          -10, -30, -20, -10,
          0,
        ]);
        for (let i = 0; i < zData.length; i++) {
          zData[i] /= 30;
        }
        const zs = w.alloc(Float32Array, zData.length);
        zs.set(zData);

        meshDrawer.drawPolygonize(positions, holes, holeCounts, points, 0.5, zs);
      }; */
      w.waitForLoad = () => modulePromise;
      w.alloc = (constructor, count) => {
        if (count > 0) {
          const size = constructor.BYTES_PER_ELEMENT * count;
          const ptr = moduleInstance._doMalloc(size);
          return new constructor(moduleInstance.HEAP8.buffer, ptr, count);
        } else {
          return new constructor(moduleInstance.HEAP8.buffer, 0, 0);
        }
      };
      w.free = ptr => {
        moduleInstance._doFree(ptr);
      };
      w.makeArenaAllocator = size => {
        const ptr = moduleInstance._makeArenaAllocator(size);
        const offset = moduleInstance.HEAP32[ptr / Uint32Array.BYTES_PER_ELEMENT];
        return {
          ptr,
          getAs(constructor) {
            return new constructor(moduleInstance.HEAP8.buffer, offset, size / constructor.BYTES_PER_ELEMENT);
          },
        };
      };
      w.makeGeometrySet = () => moduleInstance._makeGeometrySet();
      w.requestLoadBake = async (geometrySet, url) => {
        const res = await fetch(url);
        const arrayBuffer = await res.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);

        const dataOffset = moduleInstance._malloc(uint8Array.length);
        const data = moduleInstance.HEAPU8.subarray(dataOffset, dataOffset + uint8Array.length);
        data.set(uint8Array);

        moduleInstance._loadBake(
          geometrySet,
          data.byteOffset,
          data.byteLength
        );

        w.free(data.byteOffset);
      };
      w.getGeometry = (geometrySet, name) => {
        const srcNameUint8Array = textEncoder.encode(name);
        const dstNameUint8Array = w.alloc(Uint8Array, srcNameUint8Array.byteLength);
        dstNameUint8Array.set(srcNameUint8Array);

        scratchStack.u32[0] = dstNameUint8Array.byteOffset,

        moduleInstance._getGeometry(
          geometrySet,
          dstNameUint8Array.byteOffset,
          dstNameUint8Array.byteLength,
          scratchStack.u32.byteOffset + 0*Uint32Array.BYTES_PER_ELEMENT,
          scratchStack.u32.byteOffset + 1*Uint32Array.BYTES_PER_ELEMENT,
          scratchStack.u32.byteOffset + 2*Uint32Array.BYTES_PER_ELEMENT,
          scratchStack.u32.byteOffset + 3*Uint32Array.BYTES_PER_ELEMENT,
          scratchStack.u32.byteOffset + 4*Uint32Array.BYTES_PER_ELEMENT,
          scratchStack.u32.byteOffset + 5*Uint32Array.BYTES_PER_ELEMENT,
          scratchStack.u32.byteOffset + 6*Uint32Array.BYTES_PER_ELEMENT
        );

        const positionsOffset = scratchStack.u32[0];
        const uvsOffset = scratchStack.u32[1];
        const indicesOffset = scratchStack.u32[2];
        const numPositions = scratchStack.u32[3];
        const numUvs = scratchStack.u32[4];
        const numIndices = scratchStack.u32[5];
        const aabbOffset = scratchStack.u32[6];
     
        const boundingBox = new THREE.Box3(
          new THREE.Vector3().fromArray(moduleInstance.HEAPF32.subarray(aabbOffset/Float32Array.BYTES_PER_ELEMENT, aabbOffset/Float32Array.BYTES_PER_ELEMENT + 3)),
          new THREE.Vector3().fromArray(moduleInstance.HEAPF32.subarray(aabbOffset/Float32Array.BYTES_PER_ELEMENT + 3, aabbOffset/Float32Array.BYTES_PER_ELEMENT + 6)),
        );

        const positions = new Float32Array(moduleInstance.HEAP8.buffer, positionsOffset, numPositions);
        const uvs = new Float32Array(moduleInstance.HEAP8.buffer, uvsOffset, numUvs);
        const indices = new Uint32Array(moduleInstance.HEAP8.buffer, indicesOffset, numIndices);

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        geometry.setIndex(new THREE.BufferAttribute(indices, 1));
        renderer.geometries.update(geometry);

        geometry.boundingBox = boundingBox;
        
        w.free(dstNameUint8Array.byteOffset);
        
        return geometry;
      };
      /* w.requestGetGeometry = (geometrySet, name) => new Promise((accept, reject) => {
        let dstNameUint8Array;
        callStack.allocRequest(METHODS.getGeometry, true, m => {
          m.pushU32(geometrySet);

          const srcNameUint8Array = textEncoder.encode(name);
          dstNameUint8Array = w.alloc(Uint8Array, srcNameUint8Array.byteLength);
          dstNameUint8Array.set(srcNameUint8Array);
          m.pushU32(dstNameUint8Array.byteOffset);
          m.pushU32(dstNameUint8Array.byteLength);
        }, m => {
          const positionsOffset = m.pullU32();
          const uvsOffset = m.pullU32();
          const indicesOffset = m.pullU32();
          const numPositions = m.pullU32();
          const numUvs = m.pullU32();
          const numIndices = m.pullU32();
          const aabbOffset = m.pullU32();;
          const boundingBox = new THREE.Box3(
            new THREE.Vector3().fromArray(moduleInstance.HEAPF32.subarray(aabbOffset/Float32Array.BYTES_PER_ELEMENT, aabbOffset/Float32Array.BYTES_PER_ELEMENT + 3)),
            new THREE.Vector3().fromArray(moduleInstance.HEAPF32.subarray(aabbOffset/Float32Array.BYTES_PER_ELEMENT + 3, aabbOffset/Float32Array.BYTES_PER_ELEMENT + 6)),
          );

          const positions = new Float32Array(moduleInstance.HEAP8.buffer, positionsOffset, numPositions);
          const uvs = new Float32Array(moduleInstance.HEAP8.buffer, uvsOffset, numUvs);
          const indices = new Uint32Array(moduleInstance.HEAP8.buffer, indicesOffset, numIndices);

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
          geometry.setIndex(new THREE.BufferAttribute(indices, 1));
          renderer.geometries.update(geometry);

          geometry.boundingBox = boundingBox;

          w.free(dstNameUint8Array.byteOffset);

          accept(geometry);
        });
      }); */
      w.requestGetGeometries = (geometrySet, geometryRequests) => new Promise((accept, reject) => {
        let geometryRequestsOffset;
        callStack.allocRequest(METHODS.getGeometries, true, m => {
          m.pushU32(geometrySet);
          
          const geometryRequestSize = MAX_NAME_LENGTH + 10*Float32Array.BYTES_PER_ELEMENT;
          geometryRequestsOffset = moduleInstance._malloc(geometryRequestSize * geometryRequests.length);
          
          for (let i = 0; i < geometryRequests.length; i++) {
            const geometryRequest = geometryRequests[i];
            const {name, position, quaternion, scale} = geometryRequest;
            const geometryRequestOffset = geometryRequestsOffset + i*geometryRequestSize;

            const srcNameUint8Array = textEncoder.encode(name);
            const dstNameUint8Array = moduleInstance.HEAPU8.subarray(geometryRequestOffset, geometryRequestOffset + MAX_NAME_LENGTH);
            dstNameUint8Array.set(srcNameUint8Array);
            dstNameUint8Array[srcNameUint8Array.length] = 0;

            position.toArray(moduleInstance.HEAPF32, geometryRequestOffset/Float32Array.BYTES_PER_ELEMENT + MAX_NAME_LENGTH/Float32Array.BYTES_PER_ELEMENT);
            quaternion.toArray(moduleInstance.HEAPF32, geometryRequestOffset/Float32Array.BYTES_PER_ELEMENT + MAX_NAME_LENGTH/Float32Array.BYTES_PER_ELEMENT + 3);
            scale.toArray(moduleInstance.HEAPF32, geometryRequestOffset/Float32Array.BYTES_PER_ELEMENT + MAX_NAME_LENGTH/Float32Array.BYTES_PER_ELEMENT + 7);
          }
          
          m.pushU32(geometryRequestsOffset);
          m.pushU32(geometryRequests.length);
        }, m => {
          const positionsOffset = m.pullU32();
          const uvsOffset = m.pullU32();
          // const colorsOffset = m.pullU32();
          const indicesOffset = m.pullU32();
          const numPositions = m.pullU32();
          const numUvs = m.pullU32();
          // const numColors = m.pullU32();
          const numIndices = m.pullU32();

          const positions = new Float32Array(moduleInstance.HEAP8.buffer, positionsOffset, numPositions);
          const uvs = new Float32Array(moduleInstance.HEAP8.buffer, uvsOffset, numUvs);
          // const colors = new Float32Array(moduleInstance.HEAP8.buffer, colorsOffset, numColors);
          const indices = new Uint32Array(moduleInstance.HEAP8.buffer, indicesOffset, numIndices);

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
          // geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3, true));
          geometry.setIndex(new THREE.BufferAttribute(indices, 1));
          renderer.geometries.update(geometry);

          w.free(positionsOffset);
          w.free(uvsOffset);
          // w.free(colorsOffset);
          w.free(indicesOffset);

          accept(geometry);
        });
      });
      w.requestGetGeometryKeys = geometrySet => new Promise((accept, reject) => {
        callStack.allocRequest(METHODS.getGeometryKeys, true, m => {
          m.pushU32(geometrySet);
        }, m => {
          const namesOffset = m.pullU32();
          const numNames = m.pullU32();
          
          const result = [];
          for (let i = 0; i < numNames; i++) {
            const nameOffset = namesOffset + i*MAX_NAME_LENGTH;
            const nameLength = (() => {
              let j;
              for (j = 0; j < MAX_NAME_LENGTH; j++) {
                if (moduleInstance.HEAPU8[nameOffset+j] === 0) {
                  break;
                }
              }
              return j;
            })();
            const name = textDecoder.decode(moduleInstance.HEAPU8.slice(nameOffset, nameOffset + nameLength));
            result.push(name);
          }

          w.free(namesOffset);

          accept(result);
        });
      });
      w.requestAnimalGeometry = hash => new Promise((accept, reject) => {
        callStack.allocRequest(METHODS.getAnimalGeometry, false, m => {
          m.pushU32(geometrySet);
          m.pushU32(hash);
        }, m => {
          const positionsOffset = m.pullU32();
          const colorsOffset = m.pullU32();
          const indicesOffset = m.pullU32();
          const headsOffset = m.pullU32();
          const legsOffset = m.pullU32();
          const numPositions = m.pullU32();
          const numColors = m.pullU32();
          const numIndices = m.pullU32();
          const numHeads = m.pullU32();
          const numLegs = m.pullU32();
          const headPivot = m.pullF32Array(3);
          const aabb = m.pullF32Array(6);

          const positions = new Float32Array(moduleInstance.HEAP8.buffer, positionsOffset, numPositions);
          const colors = new Uint8Array(moduleInstance.HEAP8.buffer, colorsOffset, numColors);
          const indices = new Uint32Array(moduleInstance.HEAP8.buffer, indicesOffset, numIndices);
          const heads = new Float32Array(moduleInstance.HEAP8.buffer, headsOffset, numHeads);
          const legs = new Float32Array(moduleInstance.HEAP8.buffer, legsOffset, numLegs);

          accept({
            positions,
            colors,
            indices,
            heads,
            legs,
            headPivot,
            aabb,
          });
        });
      });
      /* w.requestMarchObjects = (x, y, z, geometrySet, subparcel, subparcelSpecs, allocators) => new Promise((accept, reject) => {
        let subparcelObjects;
        callStack.allocRequest(METHODS.marchObjects, false, offset => {
          const numSubparcelObjects = subparcelSpecs.length;
          subparcelObjects = w.alloc(Uint32Array, numSubparcelObjects);
          for (let i = 0; i < subparcelSpecs.length; i++) {
            subparcelObjects[i] = subparcelSpecs[i].offset;
          }

          callStack.u32[offset] = geometrySet;
          callStack.i32[offset + 1] = x;
          callStack.i32[offset + 2] = y;
          callStack.i32[offset + 3] = z;
          callStack.u32[offset + 4] = subparcel.offset;
          callStack.u32[offset + 5] = subparcelObjects.byteOffset;
          callStack.u32[offset + 6] = numSubparcelObjects;
          callStack.u32[offset + 7] = allocators.positions.ptr;
          callStack.u32[offset + 8] = allocators.uvs.ptr;
          callStack.u32[offset + 9] = allocators.ids.ptr;
          callStack.u32[offset + 10] = allocators.indices.ptr;
          callStack.u32[offset + 11] = allocators.skyLights.ptr;
          callStack.u32[offset + 12] = allocators.torchLights.ptr;
        }, offset => {
          const positionsFreeEntry = callStack.ou32[offset + 13];
          const uvsFreeEntry = callStack.ou32[offset + 14];
          const idsFreeEntry = callStack.ou32[offset + 15];
          const indicesFreeEntry = callStack.ou32[offset + 16];
          const skyLightsFreeEntry = callStack.ou32[offset + 17];
          const torchLightsFreeEntry = callStack.ou32[offset + 18];

          const positionsStart = moduleInstance.HEAPU32[positionsFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          const uvsStart = moduleInstance.HEAPU32[uvsFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          const idsStart = moduleInstance.HEAPU32[idsFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          const indicesStart = moduleInstance.HEAPU32[indicesFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          const skyLightsStart = moduleInstance.HEAPU32[skyLightsFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          const torchLightsStart = moduleInstance.HEAPU32[torchLightsFreeEntry/Uint32Array.BYTES_PER_ELEMENT];

          const positionsCount = moduleInstance.HEAPU32[positionsFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          const uvsCount = moduleInstance.HEAPU32[uvsFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          const idsCount = moduleInstance.HEAPU32[idsFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          const indicesCount = moduleInstance.HEAPU32[indicesFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          const skyLightsCount = moduleInstance.HEAPU32[skyLightsFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          const torchLightsCount = moduleInstance.HEAPU32[torchLightsFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];

          w.free(subparcelObjects.byteOffset);

          accept({
            positionsFreeEntry,
            uvsFreeEntry,
            idsFreeEntry,
            indicesFreeEntry,
            skyLightsFreeEntry,
            torchLightsFreeEntry,

            positionsStart,
            uvsStart,
            idsStart,
            indicesStart,
            skyLightsStart,
            torchLightsStart,

            positionsCount,
            uvsCount,
            idsCount,
            indicesCount,
            skyLightsCount,
            torchLightsCount,
          });
        });
      }); */
      w.getHeight = (hash, x, y, z, baseHeight) => {
        return moduleInstance._doGetHeight(
          hash,
          x,
          y,
          z,
          baseHeight
        );
      };
      /* const wormRate = 2;
      const wormRadiusBase = 2;
      const wormRadiusRate = 2;
      const objectsRate = 3;
      const potentialDefault = -0.5;
      w.requestNoise = (hash, x, y, z, baseHeight, subparcelOffset) => new Promise((accept, reject) => {
        callStack.allocRequest(METHODS.noise, false, offset => {
          callStack.u32[offset] = hash;

          callStack.f32[offset + 1] = x;
          callStack.f32[offset + 2] = y;
          callStack.f32[offset + 3] = z;
          callStack.f32[offset + 4] = baseHeight;
          callStack.f32[offset + 5] = wormRate;
          callStack.f32[offset + 6] = wormRadiusBase;
          callStack.f32[offset + 7] = wormRadiusRate;
          callStack.f32[offset + 8] = objectsRate;
          callStack.f32[offset + 9] = potentialDefault;

          callStack.u32[offset + 10] = subparcelOffset;
        }, offset => {
          accept();
        });
      });
      w.requestMarchingCubes = (seed, meshId, x, y, z, potentials, biomes, heightfield, lightfield, allocators) => new Promise((accept, reject) => {
        callStack.allocRequest(METHODS.marchingCubes, false, offset => {
          callStack.f32[offset] = meshId;

          // dims
          callStack.i32[offset + 1] = SUBPARCEL_SIZE;
          callStack.i32[offset + 2] = SUBPARCEL_SIZE;
          callStack.i32[offset + 3] = SUBPARCEL_SIZE;

          callStack.u32[offset + 4] = potentials.byteOffset;
          callStack.u32[offset + 5] = biomes.byteOffset;
          callStack.u32[offset + 6] = heightfield.byteOffset;
          callStack.u32[offset + 7] = lightfield.byteOffset;

          // shift
          callStack.f32[offset + 8] = x*SUBPARCEL_SIZE;
          callStack.f32[offset + 9] = y*SUBPARCEL_SIZE;
          callStack.f32[offset + 10] = z*SUBPARCEL_SIZE;

          // scale
          callStack.f32[offset + 11] = 1;
          callStack.f32[offset + 12] = 1;
          callStack.f32[offset + 13] = 1;

          callStack.u32[offset + 14] = allocators.positions.ptr;
          callStack.u32[offset + 15] = allocators.normals.ptr;
          callStack.u32[offset + 16] = allocators.uvs.ptr;
          // callStack.u32[offset + 17] = allocators.barycentrics.ptr;
          callStack.u32[offset + 17] = allocators.aos.ptr;
          callStack.u32[offset + 18] = allocators.ids.ptr;
          callStack.u32[offset + 19] = allocators.skyLights.ptr;
          callStack.u32[offset + 20] = allocators.torchLights.ptr;
          callStack.u32[offset + 21] = allocators.peeks.ptr;
        }, offset => {
          const positionsFreeEntry = callStack.ou32[offset + 22];
          const normalsFreeEntry = callStack.ou32[offset + 23];
          const uvsFreeEntry = callStack.ou32[offset + 24];
          const barycentricsFreeEntry = callStack.ou32[offset + 25];
          const aosFreeEntry = callStack.ou32[offset + 26];
          const idsFreeEntry = callStack.ou32[offset + 27];
          const skyLightsFreeEntry = callStack.ou32[offset + 28];
          const torchLightsFreeEntry = callStack.ou32[offset + 29];
          const peeksFreeEntry = callStack.ou32[offset + 30];

          const numOpaquePositions = callStack.ou32[offset + 31];
          const numTransparentPositions = callStack.ou32[offset + 32];

          const positionsStart = moduleInstance.HEAPU32[positionsFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          const normalsStart = moduleInstance.HEAPU32[normalsFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          const uvsStart = moduleInstance.HEAPU32[uvsFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          // const barycentricsStart = moduleInstance.HEAPU32[barycentricsFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          const aosStart = moduleInstance.HEAPU32[aosFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          const idsStart = moduleInstance.HEAPU32[idsFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          const skyLightsStart = moduleInstance.HEAPU32[skyLightsFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          const torchLightsStart = moduleInstance.HEAPU32[torchLightsFreeEntry/Uint32Array.BYTES_PER_ELEMENT];
          const peeksStart = moduleInstance.HEAPU32[peeksFreeEntry/Uint32Array.BYTES_PER_ELEMENT];

          const positionsCount = moduleInstance.HEAPU32[positionsFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          const normalsCount = moduleInstance.HEAPU32[normalsFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          const uvsCount = moduleInstance.HEAPU32[uvsFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          // const barycentricsCount = moduleInstance.HEAPU32[barycentricsFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          const aosCount = moduleInstance.HEAPU32[aosFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          const idsCount = moduleInstance.HEAPU32[idsFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          const skyLightsCount = moduleInstance.HEAPU32[skyLightsFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          const torchLightsCount = moduleInstance.HEAPU32[torchLightsFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];
          const peeksCount = moduleInstance.HEAPU32[peeksFreeEntry/Uint32Array.BYTES_PER_ELEMENT + 1];

          const _decodeArenaEntry = (allocator, freeEntry, constructor) => {
            const positionsBase = new Uint32Array(moduleInstance.HEAP8.buffer, allocator.ptr, 1)[0];
            const positionsOffset = new Uint32Array(moduleInstance.HEAP8.buffer, freeEntry, 1)[0];
            const positionsLength = new Uint32Array(moduleInstance.HEAP8.buffer, freeEntry + Uint32Array.BYTES_PER_ELEMENT, 1)[0];
            const positions = new constructor(moduleInstance.HEAP8.buffer, positionsBase + positionsOffset, positionsLength/constructor.BYTES_PER_ELEMENT);
            return positions;
          };
          const positions = _decodeArenaEntry(allocators.positions, positionsFreeEntry, Float32Array);
          const peeks = _decodeArenaEntry(allocators.peeks, peeksFreeEntry, Uint8Array);
          // console.log('loaded positions', positions, peeks);

          accept({
            positionsFreeEntry,
            normalsFreeEntry,
            uvsFreeEntry,
            // barycentricsFreeEntry,
            aosFreeEntry,
            idsFreeEntry,
            skyLightsFreeEntry,
            torchLightsFreeEntry,
            peeksFreeEntry,

            positionsStart,
            normalsStart,
            uvsStart,
            // barycentricsStart,
            aosStart,
            idsStart,
            skyLightsStart,
            torchLightsStart,
            peeksStart,

            positionsCount,
            normalsCount,
            uvsCount,
            // barycentricsCount,
            aosCount,
            idsCount,
            skyLightsCount,
            torchLightsCount,
            peeksCount,

            numOpaquePositions,
            numTransparentPositions,

            x,
            y,
            z,
          });
        });
      }); */
      w.makeTracker = function() {
        return moduleInstance._makeTracker.apply(moduleInstance, arguments);
      };
      /* w.requestBakeGeometry = (positions, indices) => new Promise((accept, reject) => {
        callStack.allocRequest(METHODS.bakeGeometry, false, offset => {
          callStack.u32[offset] = positions.byteOffset;
          callStack.u32[offset + 1] = indices ? indices.byteOffset : 0;
          callStack.u32[offset + 2] = positions.length;
          callStack.u32[offset + 3] = indices ? indices.length : 0;
        }, offset => {
          const writeStream = callStack.ou32[offset + 4];
          accept(writeStream);
        });
      });
      w.releaseBakedGeometry = writeStream => {
        moduleInstance._releaseBakedGeometry(writeStream);
      };
      w.registerBakedGeometry = (meshId, writeStream, x, y, z) => {
        scratchStack.f32[0] = x*SUBPARCEL_SIZE + SUBPARCEL_SIZE/2;
        scratchStack.f32[1] = y*SUBPARCEL_SIZE + SUBPARCEL_SIZE/2;
        scratchStack.f32[2] = z*SUBPARCEL_SIZE + SUBPARCEL_SIZE/2;

        scratchStack.f32[3] = 0;
        scratchStack.f32[4] = 0;
        scratchStack.f32[5] = 0;
        scratchStack.f32[6] = 1;

        moduleInstance._registerBakedGeometry(
          meshId,
          writeStream,
          scratchStack.f32.byteOffset,
          scratchStack.f32.byteOffset + 3*Float32Array.BYTES_PER_ELEMENT,
          scratchStack.u32.byteOffset + 7*Uint32Array.BYTES_PER_ELEMENT
        );
        return scratchStack.u32[7];
      };
      w.registerBoxGeometry = (meshId, positionData, quaternionData, w, h, d) => {
        positionData.toArray(scratchStack.f32, 0);
        quaternionData.toArray(scratchStack.f32, 3);

        moduleInstance._registerBoxGeometry(
          meshId,
          scratchStack.f32.byteOffset,
          scratchStack.f32.byteOffset + 3*Float32Array.BYTES_PER_ELEMENT,
          w,
          h,
          d,
          scratchStack.u32.byteOffset + 7*Uint32Array.BYTES_PER_ELEMENT
        );
        return scratchStack.u32[7];
      };
      w.registerCapsuleGeometry = (meshId, positionData, quaternionData, radius, halfHeight) => {
        positionData.toArray(scratchStack.f32, 0);
        quaternionData.toArray(scratchStack.f32, 3);

        moduleInstance._registerCapsuleGeometry(
          meshId,
          scratchStack.f32.byteOffset,
          scratchStack.f32.byteOffset + 3*Float32Array.BYTES_PER_ELEMENT,
          radius,
          halfHeight,
          scratchStack.u32.byteOffset + 7*Uint32Array.BYTES_PER_ELEMENT
        );
        return scratchStack.u32[7];
      };
      w.unregisterGeometry = ptr => {
        moduleInstance._unregisterGeometry(ptr);
      }; */
      w.makePhysics = () => moduleInstance._makePhysics();
      w.simulatePhysics = (physics, updates, elapsedTime) => {
        const maxNumUpdates = 10;
        let index = 0;
        const ids = scratchStack.u32.subarray(index, index + maxNumUpdates);
        index += maxNumUpdates;
        const positions = scratchStack.f32.subarray(index, index + maxNumUpdates*3);
        index += maxNumUpdates*3;
        const quaternions = scratchStack.f32.subarray(index, index + maxNumUpdates*4);
        index += maxNumUpdates*4;

        for (let i = 0; i < updates.length; i++) {
          const update = updates[i];
          ids[i] = update.id;
          update.position.toArray(positions, i*3);
          update.quaternion.toArray(quaternions, i*4);
        }

        const numNewUpdates = moduleInstance._simulatePhysics(
          physics,
          ids.byteOffset,
          positions.byteOffset,
          quaternions.byteOffset,
          updates.length,
          elapsedTime
        );
        
        const newUpdates = Array(numNewUpdates);
        for (let i = 0; i < numNewUpdates; i++) {
          newUpdates[i] = {
            id: ids[i],
            position: new THREE.Vector3().fromArray(positions, i*3),
            quaternion: new THREE.Quaternion().fromArray(quaternions, i*4),
          };
        }
        
        return newUpdates;
      };
      w.raycastPhysics = (physics, p, q) => {
        p.toArray(scratchStack.f32, 0);
        localVector.set(0, 0, -1)
          .applyQuaternion(q)
          .toArray(scratchStack.f32, 3);
        // geometryManager.currentChunkMesh.matrixWorld.decompose(localVector, localQuaternion, localVector2);
        localVector.set(0, 0, 0).toArray(scratchStack.f32, 6);
        localQuaternion.set(0, 0, 0, 1).toArray(scratchStack.f32, 9);

        const originOffset = scratchStack.f32.byteOffset;
        const directionOffset = scratchStack.f32.byteOffset + 3 * Float32Array.BYTES_PER_ELEMENT;
        const meshPositionOffset = scratchStack.f32.byteOffset + 6 * Float32Array.BYTES_PER_ELEMENT;
        const meshQuaternionOffset = scratchStack.f32.byteOffset + 9 * Float32Array.BYTES_PER_ELEMENT;

        const hitOffset = scratchStack.f32.byteOffset + 13 * Float32Array.BYTES_PER_ELEMENT;
        const pointOffset = scratchStack.f32.byteOffset + 14 * Float32Array.BYTES_PER_ELEMENT;
        const normalOffset = scratchStack.f32.byteOffset + 17 * Float32Array.BYTES_PER_ELEMENT;
        const distanceOffset = scratchStack.f32.byteOffset + 20 * Float32Array.BYTES_PER_ELEMENT;
        const objectIdOffset = scratchStack.u32.byteOffset + 21 * Float32Array.BYTES_PER_ELEMENT;
        const faceIndexOffset = scratchStack.u32.byteOffset + 22 * Float32Array.BYTES_PER_ELEMENT;
        const positionOffset = scratchStack.u32.byteOffset + 23 * Float32Array.BYTES_PER_ELEMENT;
        const quaternionOffset = scratchStack.u32.byteOffset + 26 * Float32Array.BYTES_PER_ELEMENT;

        /* const raycastArgs = {
          origin: allocator.alloc(Float32Array, 3),
          direction: allocator.alloc(Float32Array, 3),
          meshPosition: allocator.alloc(Float32Array, 3),
          meshQuaternion: allocator.alloc(Float32Array, 4),
          hit: allocator.alloc(Uint32Array, 1),
          point: allocator.alloc(Float32Array, 3),
          normal: allocator.alloc(Float32Array, 3),
          distance: allocator.alloc(Float32Array, 1),
          meshId: allocator.alloc(Uint32Array, 1),
          faceIndex: allocator.alloc(Uint32Array, 1),
        }; */

        moduleInstance._raycastPhysics(
          physics,
          originOffset,
          directionOffset,
          meshPositionOffset,
          meshQuaternionOffset,
          hitOffset,
          pointOffset,
          normalOffset,
          distanceOffset,
          objectIdOffset,
          faceIndexOffset,
          positionOffset,
          quaternionOffset,
        );
        const objectId = scratchStack.u32[21];
        const faceIndex = scratchStack.u32[22];
        const objectPosition = scratchStack.f32.slice(23, 26);
        const objectQuaternion = scratchStack.f32.slice(26, 30);

        return scratchStack.u32[13] ? {
          point: scratchStack.f32.slice(14, 17),
          normal: scratchStack.f32.slice(17, 20),
          distance: scratchStack.f32[20],
          meshId: scratchStack.u32[21],
          objectId,
          faceIndex,
          objectPosition,
          objectQuaternion,
        } : null;
      };
      w.collidePhysics = (physics, radius, halfHeight, p, q, maxIter) => {
        p.toArray(scratchStack.f32, 0);
        localQuaternion.copy(q)
          .premultiply(capsuleUpQuaternion)
          .toArray(scratchStack.f32, 3);
        // geometryManager.currentChunkMesh.matrixWorld.decompose(localVector, localQuaternion, localVector2);
        localVector.set(0, 0, 0).toArray(scratchStack.f32, 7);
        localQuaternion.set(0, 0, 0, 1).toArray(scratchStack.f32, 10);

        const positionOffset = scratchStack.f32.byteOffset;
        const quaternionOffset = scratchStack.f32.byteOffset + 3 * Float32Array.BYTES_PER_ELEMENT;
        const meshPositionOffset = scratchStack.f32.byteOffset + 7 * Float32Array.BYTES_PER_ELEMENT;
        const meshQuaternionOffset = scratchStack.f32.byteOffset + 10 * Float32Array.BYTES_PER_ELEMENT;

        const hitOffset = scratchStack.f32.byteOffset + 14 * Float32Array.BYTES_PER_ELEMENT;
        const directionOffset = scratchStack.f32.byteOffset + 15 * Float32Array.BYTES_PER_ELEMENT;
        const groundedOffset = scratchStack.f32.byteOffset + 18 * Float32Array.BYTES_PER_ELEMENT;

        /* const collideArgs = {
          position: allocator.alloc(Float32Array, 3),
          quaternion: allocator.alloc(Float32Array, 4),
          meshPosition: allocator.alloc(Float32Array, 3),
          meshQuaternion: allocator.alloc(Float32Array, 4),
          hit: allocator.alloc(Uint32Array, 1),
          direction: allocator.alloc(Float32Array, 3),
          grounded: allocator.alloc(Uint32Array, 1),
        }; */
        
        /* console.log('collide physics', [physics,
          radius,
          halfHeight,
          positionOffset,
          quaternionOffset,
          meshPositionOffset,
          meshQuaternionOffset,
          maxIter,
          hitOffset,
          directionOffset,
          groundedOffset]); */

        moduleInstance._collidePhysics(
          physics,
          radius,
          halfHeight,
          positionOffset,
          quaternionOffset,
          meshPositionOffset,
          meshQuaternionOffset,
          maxIter,
          hitOffset,
          directionOffset,
          groundedOffset,
        );

        return scratchStack.u32[14] ? {
          direction: scratchStack.f32.slice(15, 18),
          grounded: !!scratchStack.u32[18],
        } : null;
      };
      w.getSubparcelArenaSpec = subparcelOffset => {
        const subparcelArenaSpecOffset = scratchStack.u32.byteOffset;
        moduleInstance._getSubparcelArenaSpec(subparcelOffset, subparcelArenaSpecOffset);
        const subparcelArenaSpecOffset32 = subparcelArenaSpecOffset/Uint32Array.BYTES_PER_ELEMENT;

        let index = 0;
        let landArenaSpec, vegetationArenaSpec, thingArenaSpec;
        {
          const positionsFreeEntry = scratchStack.u32[index++];
          const normalsFreeEntry = scratchStack.u32[index++];
          const uvsFreeEntry = scratchStack.u32[index++];
          const aosFreeEntry = scratchStack.u32[index++];
          const idsFreeEntry = scratchStack.u32[index++];
          const skyLightsFreeEntry = scratchStack.u32[index++];
          const torchLightsFreeEntry = scratchStack.u32[index++];

          landArenaSpec = {
            positionsFreeEntry,
            normalsFreeEntry,
            uvsFreeEntry,
            aosFreeEntry,
            idsFreeEntry,
            skyLightsFreeEntry,
            torchLightsFreeEntry,
          };
        }
        {
          const positionsFreeEntry = scratchStack.u32[index++];
          const uvsFreeEntry = scratchStack.u32[index++];
          const idsFreeEntry = scratchStack.u32[index++];
          const indicesFreeEntry = scratchStack.u32[index++];
          const skyLightsFreeEntry = scratchStack.u32[index++];
          const torchLightsFreeEntry = scratchStack.u32[index++];

          vegetationArenaSpec = {
            positionsFreeEntry,
            uvsFreeEntry,
            idsFreeEntry,
            indicesFreeEntry,
            skyLightsFreeEntry,
            torchLightsFreeEntry,
          };
        }
        {
          const positionsFreeEntry = scratchStack.u32[index++];
          const uvsFreeEntry = scratchStack.u32[index++];
          const atlasUvsFreeEntry = scratchStack.u32[index++];
          const idsFreeEntry = scratchStack.u32[index++];
          const indicesFreeEntry = scratchStack.u32[index++];
          const skyLightsFreeEntry = scratchStack.u32[index++];
          const torchLightsFreeEntry = scratchStack.u32[index++];

          thingArenaSpec = {
            positionsFreeEntry,
            uvsFreeEntry,
            atlasUvsFreeEntry,
            idsFreeEntry,
            indicesFreeEntry,
            skyLightsFreeEntry,
            torchLightsFreeEntry,
          };
        }
        return [landArenaSpec, vegetationArenaSpec, thingArenaSpec];
      };
      w.tickCull = (tracker, position, matrix) => {
        position.toArray(scratchStack.f32, 0);
        matrix.toArray(scratchStack.f32, 3);

        const positionOffset = scratchStack.f32.byteOffset;
        const matrixOffset = scratchStack.f32.byteOffset + 3 * Float32Array.BYTES_PER_ELEMENT;
        const numLandCullResultsOffset = scratchStack.f32.byteOffset + (3 + 16) * Float32Array.BYTES_PER_ELEMENT;
        const numVegetationCullResultsOffset = scratchStack.f32.byteOffset + (3 + 16 + 1) * Float32Array.BYTES_PER_ELEMENT;
        const numThingCullResultsOffset = scratchStack.f32.byteOffset + (3 + 16 + 2) * Float32Array.BYTES_PER_ELEMENT;
        const landCullResultsOffset = scratchStack.f32.byteOffset + (3 + 16 + 3) * Float32Array.BYTES_PER_ELEMENT;
        const vegetationCullResultsOffset = scratchStack.f32.byteOffset + (3 + 16 + 3 + 4096) * Float32Array.BYTES_PER_ELEMENT;
        const thingCullResultsOffset = scratchStack.f32.byteOffset + (3 + 16 + 3 + 4096 * 2) * Float32Array.BYTES_PER_ELEMENT;

        moduleInstance._tickCull(
          tracker,
          positionOffset,
          matrixOffset,
          landCullResultsOffset,
          numLandCullResultsOffset,
          vegetationCullResultsOffset,
          numVegetationCullResultsOffset,
          thingCullResultsOffset,
          numThingCullResultsOffset,
        );

        const numLandCullResults = scratchStack.u32[3 + 16];
        const landCullResults = Array(numLandCullResults);
        for (let i = 0; i < landCullResults.length; i++) {
          landCullResults[i] = {
            start: scratchStack.u32[3 + 16 + 3 + i * 3],
            count: scratchStack.u32[3 + 16 + 3 + i * 3 + 1],
            materialIndex: scratchStack.u32[3 + 16 + 3 + i * 3 + 2],
          };
        }
        const numVegetationCullResults = scratchStack.u32[3 + 16 + 1];
        const vegetationCullResults = Array(numVegetationCullResults);
        for (let i = 0; i < vegetationCullResults.length; i++) {
          vegetationCullResults[i] = {
            start: scratchStack.u32[3 + 16 + 3 + 4096 + i * 3],
            count: scratchStack.u32[3 + 16 + 3 + 4096 + i * 3 + 1],
            materialIndex: scratchStack.u32[3 + 16 + 3 + 4096 + i * 3 + 2],
          };
        }
        const numThingCullResults = scratchStack.u32[3 + 16 + 1];
        const thingCullResults = Array(numThingCullResults);
        for (let i = 0; i < thingCullResults.length; i++) {
          thingCullResults[i] = {
            start: scratchStack.u32[3 + 16 + 3 + 4096 * 2 + i * 3],
            count: scratchStack.u32[3 + 16 + 3 + 4096 * 2 + i * 3 + 1],
            materialIndex: scratchStack.u32[3 + 16 + 3 + 4096 * 2 + i * 3 + 2],
          };
        }
        return [landCullResults, vegetationCullResults, thingCullResults];
      };
      /* w.getSubparcel = (tracker, x, y, z) => new Promise((accept, reject) => {
        callStack.allocRequest(METHODS.getSubparcel, true, offset => {
          callStack.u32[offset] = tracker;
          callStack.u32[offset + 1] = x;
          callStack.u32[offset + 2] = y;
          callStack.u32[offset + 3] = z;
        }, offset => {
          const subparcelPtr = callStack.ou32[offset++];
          const subparcelSharedPtr = callStack.ou32[offset++];
          if (subparcelSharedPtr) {
            const numObjects = moduleInstance.HEAPU32[(subparcelPtr + planet.Subparcel.offsets.numObjects)/Uint32Array.BYTES_PER_ELEMENT];
            console.log('got num objects', numObjects);

            w.requestReleaseSubparcel()
              .then(accept, reject);
          } else {
            console.log('no subparcel');
          }
        });
      }); */
      // window.getSubparcel = (x, y, z) => w.getSubparcel(tracker, x, y, z);
      w.requestReleaseSubparcel = (tracker, subparcelSharedPtr) => new Promise((accept, reject) => {
        callStack.allocRequest(METHODS.releaseSubparcel, true, m => {
          m.pushU32(tracker);
          m.pushU32(subparcelSharedPtr);
        }, m => {
          accept();
        });
      });
      w.requestAddObject = (tracker, geometrySet, name, position, quaternion) => new Promise((accept, reject) => {
        callStack.allocRequest(METHODS.addObject, true, m => {
          m.pushU32(tracker);
          m.pushU32(geometrySet);

          const srcNameUint8Array = textEncoder.encode(name);
          const srcNameUint8Array2 = new Uint8Array(MAX_NAME_LENGTH);
          srcNameUint8Array2.set(srcNameUint8Array);
          srcNameUint8Array2[srcNameUint8Array.byteLength] = 0;
          m.pushU8Array(srcNameUint8Array2);

          m.pushF32Array(position.toArray(new Float32Array(3)));
          m.pushF32Array(quaternion.toArray(new Float32Array(4)));
        }, m => {
          const objectId = m.pullU32();
          const numSubparcels = m.pullU32();
          // console.log('num subparcels add', numSubparcels);
          for (let i = 0; i < numSubparcels; i++) {
            const subparcelOffset = m.pullU32();
            const [landArenaSpec, vegetationArenaSpec, thingArenaSpec] = geometryWorker.getSubparcelArenaSpec(subparcelOffset);
            const {
              positionsFreeEntry,
              uvsFreeEntry,
              idsFreeEntry,
              indicesFreeEntry,
              skyLightsFreeEntry,
              torchLightsFreeEntry,
            } = vegetationArenaSpec;

            const positionsStart = moduleInstance.HEAPU32[positionsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const uvsStart = moduleInstance.HEAPU32[uvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const idsStart = moduleInstance.HEAPU32[idsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const indicesStart = moduleInstance.HEAPU32[indicesFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const skyLightsStart = moduleInstance.HEAPU32[skyLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const torchLightsStart = moduleInstance.HEAPU32[torchLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];

            const positionsCount = moduleInstance.HEAPU32[positionsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const uvsCount = moduleInstance.HEAPU32[uvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const idsCount = moduleInstance.HEAPU32[idsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const indicesCount = moduleInstance.HEAPU32[indicesFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const skyLightsCount = moduleInstance.HEAPU32[skyLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const torchLightsCount = moduleInstance.HEAPU32[torchLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];

            /* const _decodeArenaEntry = (allocator, freeEntry, constructor) => {
              const positionsBase = new Uint32Array(moduleInstance.HEAP8.buffer, allocator.ptr, 1)[0];
              const positionsOffset = new Uint32Array(moduleInstance.HEAP8.buffer, freeEntry, 1)[0];
              const positionsLength = new Uint32Array(moduleInstance.HEAP8.buffer, freeEntry + Uint32Array.BYTES_PER_ELEMENT, 1)[0];
              const positions = new constructor(moduleInstance.HEAP8.buffer, positionsBase + positionsOffset, positionsLength/constructor.BYTES_PER_ELEMENT);
              return positions;
            };
            const positions = _decodeArenaEntry(vegetationAllocators.positions, positionsFreeEntry, Float32Array);
            const uvs = _decodeArenaEntry(vegetationAllocators.uvs, uvsFreeEntry, Float32Array);
            const ids = _decodeArenaEntry(vegetationAllocators.ids, idsFreeEntry, Float32Array);
            const indices = _decodeArenaEntry(vegetationAllocators.indices, indicesFreeEntry, Uint32Array);
            const skyLights = _decodeArenaEntry(vegetationAllocators.skyLights, skyLightsFreeEntry, Uint8Array);
            const torchLights = _decodeArenaEntry(vegetationAllocators.torchLights, torchLightsFreeEntry, Uint8Array);
            console.log('got positions', {positions, uvs, ids, indices, skyLights, torchLights}); */

            geometryManager.currentVegetationMesh.updateGeometry({
              positionsStart,
              uvsStart,
              idsStart,
              indicesStart,
              skyLightsStart,
              torchLightsStart,

              positionsCount,
              uvsCount,
              idsCount,
              indicesCount,
              skyLightsCount,
              torchLightsCount,
            });
          }
          callStack.allocRequest(METHODS.releaseAddRemoveObject, true, m2 => {
            m2.pushU32(tracker);
            m2.pushU32(numSubparcels);
            for (let i = 0; i < numSubparcels; i++) {
              m2.pushU32(m.pullU32());
            }
          }, m => {
            // console.log('done release', numSubparcels);
            accept({
              objectId,
            });
          });
        });
      });
      w.requestRemoveObject = (tracker, geometrySet, sx, sy, sz, objectId) => new Promise((accept, reject) => {
        callStack.allocRequest(METHODS.removeObject, true, m => {
          m.pushU32(tracker);
          m.pushU32(geometrySet);
          m.pushI32(sx);
          m.pushI32(sy);
          m.pushI32(sz);
          m.pushU32(objectId);
        }, m => {
          const numSubparcels = m.pullU32();
          for (let i = 0; i < numSubparcels; i++) {
            const subparcelOffset = m.pullU32();
            const [landArenaSpec, vegetationArenaSpec, thingArenaSpec] = geometryWorker.getSubparcelArenaSpec(subparcelOffset);
            const {
              positionsFreeEntry,
              uvsFreeEntry,
              idsFreeEntry,
              indicesFreeEntry,
              skyLightsFreeEntry,
              torchLightsFreeEntry,
            } = vegetationArenaSpec;

            const positionsStart = moduleInstance.HEAPU32[positionsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const uvsStart = moduleInstance.HEAPU32[uvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const idsStart = moduleInstance.HEAPU32[idsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const indicesStart = moduleInstance.HEAPU32[indicesFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const skyLightsStart = moduleInstance.HEAPU32[skyLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const torchLightsStart = moduleInstance.HEAPU32[torchLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];

            const positionsCount = moduleInstance.HEAPU32[positionsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const uvsCount = moduleInstance.HEAPU32[uvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const idsCount = moduleInstance.HEAPU32[idsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const indicesCount = moduleInstance.HEAPU32[indicesFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const skyLightsCount = moduleInstance.HEAPU32[skyLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const torchLightsCount = moduleInstance.HEAPU32[torchLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];

            /* const _decodeArenaEntry = (allocator, freeEntry, constructor) => {
              const positionsBase = new Uint32Array(moduleInstance.HEAP8.buffer, allocator.ptr, 1)[0];
              const positionsOffset = new Uint32Array(moduleInstance.HEAP8.buffer, freeEntry, 1)[0];
              const positionsLength = new Uint32Array(moduleInstance.HEAP8.buffer, freeEntry + Uint32Array.BYTES_PER_ELEMENT, 1)[0];
              const positions = new constructor(moduleInstance.HEAP8.buffer, positionsBase + positionsOffset, positionsLength/constructor.BYTES_PER_ELEMENT);
              return positions;
            };
            const positions = _decodeArenaEntry(vegetationAllocators.positions, positionsFreeEntry, Float32Array);
            const uvs = _decodeArenaEntry(vegetationAllocators.uvs, uvsFreeEntry, Float32Array);
            const ids = _decodeArenaEntry(vegetationAllocators.ids, idsFreeEntry, Float32Array);
            const indices = _decodeArenaEntry(vegetationAllocators.indices, indicesFreeEntry, Uint32Array);
            const skyLights = _decodeArenaEntry(vegetationAllocators.skyLights, skyLightsFreeEntry, Uint8Array);
            const torchLights = _decodeArenaEntry(vegetationAllocators.torchLights, torchLightsFreeEntry, Uint8Array);
            console.log('got positions', {positions, uvs, ids, indices, skyLights, torchLights}); */

            geometryManager.currentVegetationMesh.updateGeometry({
              positionsStart,
              uvsStart,
              idsStart,
              indicesStart,
              skyLightsStart,
              torchLightsStart,

              positionsCount,
              uvsCount,
              idsCount,
              indicesCount,
              skyLightsCount,
              torchLightsCount,
            });
          }
          callStack.allocRequest(METHODS.releaseAddRemoveObject, true, m2 => {
            m2.pushU32(tracker);
            m2.pushU32(numSubparcels);
            for (let i = 0; i < numSubparcels; i++) {
              m2.pushU32(m.pullU32());
            }
          }, m => {
            // console.log('done release', numSubparcels);
            accept();
          });
        });
      });
      w.requestMine = (tracker, p, delta) => new Promise((accept, reject) => {
        callStack.allocRequest(METHODS.mine, true, m => {
          m.pushU32(tracker);
          m.pushF32Array(p.toArray(new Float32Array(3)));
          m.pushF32(delta);
        }, m => {
          const numSubparcels = m.pullU32();
          for (let i = 0; i < numSubparcels; i++) {
            const subparcelOffset = m.pullU32();
            const [landArenaSpec, vegetationArenaSpec, thingArenaSpec] = geometryWorker.getSubparcelArenaSpec(subparcelOffset);
            const {
              positionsFreeEntry,
              normalsFreeEntry,
              uvsFreeEntry,
              aosFreeEntry,
              idsFreeEntry,
              skyLightsFreeEntry,
              torchLightsFreeEntry,
            } = landArenaSpec;

            const positionsStart = moduleInstance.HEAPU32[positionsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const normalsStart = moduleInstance.HEAPU32[normalsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const uvsStart = moduleInstance.HEAPU32[uvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const aosStart = moduleInstance.HEAPU32[aosFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const idsStart = moduleInstance.HEAPU32[idsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const skyLightsStart = moduleInstance.HEAPU32[skyLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const torchLightsStart = moduleInstance.HEAPU32[torchLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];

            const positionsCount = moduleInstance.HEAPU32[positionsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const normalsCount = moduleInstance.HEAPU32[normalsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const uvsCount = moduleInstance.HEAPU32[uvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const aosCount = moduleInstance.HEAPU32[aosFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const idsCount = moduleInstance.HEAPU32[idsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const skyLightsCount = moduleInstance.HEAPU32[skyLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const torchLightsCount = moduleInstance.HEAPU32[torchLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];

            /* const _decodeArenaEntry = (allocator, freeEntry, constructor) => {
              const positionsBase = new Uint32Array(moduleInstance.HEAP8.buffer, allocator.ptr, 1)[0];
              const positionsOffset = new Uint32Array(moduleInstance.HEAP8.buffer, freeEntry, 1)[0];
              const positionsLength = new Uint32Array(moduleInstance.HEAP8.buffer, freeEntry + Uint32Array.BYTES_PER_ELEMENT, 1)[0];
              const positions = new constructor(moduleInstance.HEAP8.buffer, positionsBase + positionsOffset, positionsLength/constructor.BYTES_PER_ELEMENT);
              return positions;
            };
            const positions = _decodeArenaEntry(landAllocators.positions, positionsFreeEntry, Float32Array);
            const normals = _decodeArenaEntry(landAllocators.normals, normalsFreeEntry, Float32Array);
            const uvs = _decodeArenaEntry(landAllocators.uvs, uvsFreeEntry, Float32Array);
            const aos = _decodeArenaEntry(landAllocators.aos, aosFreeEntry, Uint8Array);
            const skyLights = _decodeArenaEntry(landAllocators.skyLights, skyLightsFreeEntry, Uint8Array);
            const torchLights = _decodeArenaEntry(landAllocators.torchLights, torchLightsFreeEntry, Uint8Array);
            console.log('got positions', {positions, normals, uvs, aos, skyLights, torchLights}); */

            geometryManager.currentChunkMesh.updateGeometry({
              positionsStart,
              normalsStart,
              uvsStart,
              aosStart,
              idsStart,
              skyLightsStart,
              torchLightsStart,

              positionsCount,
              normalsCount,
              uvsCount,
              aosCount,
              idsCount,
              skyLightsCount,
              torchLightsCount,
            });
          }

          callStack.allocRequest(METHODS.releaseAddRemoveObject, true, m2 => {
            m2.pushU32(tracker);
            m2.pushU32(numSubparcels);
            for (let i = 0; i < numSubparcels; i++) {
              m2.pushU32(m.pullU32());
            }
          }, m => {
            // console.log('done release', numSubparcels);
            accept();
          });
        });
      });
      w.requestLight = (tracker, p, delta) => new Promise((accept, reject) => {
        callStack.allocRequest(METHODS.light, true, m => {
          m.pushU32(tracker);
          m.pushF32Array(p.toArray(new Float32Array(3)));
          m.pushF32(delta);
        }, m => {
          const numSubparcels = m.pullU32();
          for (let i = 0; i < numSubparcels; i++) {
            {
              const positionsFreeEntry = m.pullU32();
              const normalsFreeEntry = m.pullU32();
              const uvsFreeEntry = m.pullU32();
              const aosFreeEntry = m.pullU32();
              const idsFreeEntry = m.pullU32();
              const skyLightsFreeEntry = m.pullU32();
              const torchLightsFreeEntry = m.pullU32();

              const positionsStart = moduleInstance.HEAPU32[positionsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
              const normalsStart = moduleInstance.HEAPU32[normalsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
              const uvsStart = moduleInstance.HEAPU32[uvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
              const aosStart = moduleInstance.HEAPU32[aosFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
              const idsStart = moduleInstance.HEAPU32[idsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
              const skyLightsStart = moduleInstance.HEAPU32[skyLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
              const torchLightsStart = moduleInstance.HEAPU32[torchLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];

              const positionsCount = moduleInstance.HEAPU32[positionsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
              const normalsCount = moduleInstance.HEAPU32[normalsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
              const uvsCount = moduleInstance.HEAPU32[uvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
              const aosCount = moduleInstance.HEAPU32[aosFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
              const idsCount = moduleInstance.HEAPU32[idsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
              const skyLightsCount = moduleInstance.HEAPU32[skyLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
              const torchLightsCount = moduleInstance.HEAPU32[torchLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];

              geometryManager.currentChunkMesh.updateGeometry({
                positionsStart,
                normalsStart,
                uvsStart,
                aosStart,
                idsStart,
                skyLightsStart,
                torchLightsStart,

                positionsCount,
                normalsCount,
                uvsCount,
                aosCount,
                idsCount,
                skyLightsCount,
                torchLightsCount,
              });
            }
            {
              const positionsFreeEntry = m.pullU32();
              const uvsFreeEntry = m.pullU32();
              const idsFreeEntry = m.pullU32();
              const indicesFreeEntry = m.pullU32();
              const skyLightsFreeEntry = m.pullU32();
              const torchLightsFreeEntry = m.pullU32();

              const positionsStart = moduleInstance.HEAPU32[positionsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
              const uvsStart = moduleInstance.HEAPU32[uvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
              const idsStart = moduleInstance.HEAPU32[idsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
              const indicesStart = moduleInstance.HEAPU32[indicesFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
              const skyLightsStart = moduleInstance.HEAPU32[skyLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
              const torchLightsStart = moduleInstance.HEAPU32[torchLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];

              const positionsCount = moduleInstance.HEAPU32[positionsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
              const uvsCount = moduleInstance.HEAPU32[uvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
              const idsCount = moduleInstance.HEAPU32[idsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
              const indicesCount = moduleInstance.HEAPU32[indicesFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
              const skyLightsCount = moduleInstance.HEAPU32[skyLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
              const torchLightsCount = moduleInstance.HEAPU32[torchLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];

              geometryManager.currentVegetationMesh.updateGeometry({
                positionsStart,
                uvsStart,
                idsStart,
                indicesStart,
                skyLightsStart,
                torchLightsStart,

                positionsCount,
                uvsCount,
                idsCount,
                indicesCount,
                skyLightsCount,
                torchLightsCount,
              });
            }
          }
          callStack.allocRequest(METHODS.releaseAddRemoveObject, true, m2 => {
            m2.pushU32(tracker);
            m2.pushU32(numSubparcels);
            for (let i = 0; i < numSubparcels; i++) {
              m2.pushU32(m.pullU32());
            }
          }, m => {
            // console.log('done release', numSubparcels);
            accept();
          });
        });
      });
      w.requestAddThingGeometry = (tracker, geometrySet, name, positions, uvs, indices, texture) => new Promise((accept, reject) => {
        let positionOffset, uvOffset, indexOffset, textureOffset;
        callStack.allocRequest(METHODS.addThingGeometry, true, m => {
          m.pushU32(tracker);
          m.pushU32(geometrySet);

          if (typeof name === 'string') {
            const srcNameUint8Array = textEncoder.encode(name);
            const srcNameUint8Array2 = new Uint8Array(MAX_NAME_LENGTH);
            srcNameUint8Array2.set(srcNameUint8Array);
            srcNameUint8Array2[srcNameUint8Array.byteLength] = 0;
            m.pushU8Array(srcNameUint8Array2);
          } else {
            const srcNameUint8Array2 = new Uint8Array(MAX_NAME_LENGTH);
            srcNameUint8Array2.set(name);
            srcNameUint8Array2[name.byteLength] = 0;
            m.pushU8Array(srcNameUint8Array2);
          }

          positionOffset = moduleInstance._malloc(positions.length * Float32Array.BYTES_PER_ELEMENT);
          moduleInstance.HEAPF32.set(positions, positionOffset/Float32Array.BYTES_PER_ELEMENT);
          m.pushU32(positions);

          uvOffset = moduleInstance._malloc(uvs.length * Float32Array.BYTES_PER_ELEMENT);
          moduleInstance.HEAPF32.set(positions, uvOffset/Float32Array.BYTES_PER_ELEMENT);
          m.pushU32(uvOffset);

          indexOffset = moduleInstance._malloc(indices.length * Uint32Array.BYTES_PER_ELEMENT);
          moduleInstance.HEAPU32.set(indices, indexOffset/Uint32Array.BYTES_PER_ELEMENT);
          m.pushU32(indexOffset);

          m.pushU32(positions.length);
          m.pushU32(uvs.length);
          m.pushU32(indices.length);

          textureOffset = moduleInstance._malloc(texture.length);
          moduleInstance.HEAPU8.set(texture, textureOffset);
          m.pushU32(textureOffset);
        }, m => {
          accept();
          
          w.free(positionOffset);
          w.free(uvOffset);
          w.free(indexOffset);
          w.free(textureOffset);
        });
      });
      w.requestAddThing = (tracker, geometrySet, name, position, quaternion, scale) => new Promise((accept, reject) => {
        callStack.allocRequest(METHODS.addThing, true, offset => {
          m.pushU32(tracker);
          m.pushU32(geometrySet);

          if (typeof name === 'string') {
            const srcNameUint8Array = textEncoder.encode(name);
            const srcNameUint8Array2 = new Uint8Array(MAX_NAME_LENGTH);
            srcNameUint8Array2.set(srcNameUint8Array);
            srcNameUint8Array2[srcNameUint8Array.byteLength] = 0;
            m.pushU8Array(srcNameUint8Array2);
          } else {
            const srcNameUint8Array2 = new Uint8Array(MAX_NAME_LENGTH);
            srcNameUint8Array2.set(name);
            srcNameUint8Array2[name.byteLength] = 0;
            m.pushU8Array(srcNameUint8Array2);
          }

          m.pushF32Array(position.toArray(new Float32Array(3)));
          m.pushF32Array(quaternion.toArray(new Float32Array(4)));
          m.pushF32Array(scale.toArray(new Float32Array(4)));
        }, m => {
          const objectId = m.pullU32();
          const textureOffset = m.pullU32();
          if (textureOffset) {
            const textureData = new Uint8Array(moduleInstance.HEAP8.buffer, textureOffset, thingTextureSize * thingTextureSize * 4);
            currentThingMesh.updateTexture(textureData);
          }

          const numSubparcels = m.pullU32();
          for (let i = 0; i < numSubparcels; i++) {
            const subparcelOffset = m.pullU32();
            const [landArenaSpec, vegetationArenaSpec, thingArenaSpec] = geometryWorker.getSubparcelArenaSpec(subparcelOffset);
            const {
              positionsFreeEntry,
              uvsFreeEntry,
              atlasUvsFreeEntry,
              idsFreeEntry,
              indicesFreeEntry,
              skyLightsFreeEntry,
              torchLightsFreeEntry,
            } = thingArenaSpec;

            const positionsStart = moduleInstance.HEAPU32[positionsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const uvsStart = moduleInstance.HEAPU32[uvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const atlasUvsStart = moduleInstance.HEAPU32[atlasUvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const idsStart = moduleInstance.HEAPU32[idsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const indicesStart = moduleInstance.HEAPU32[indicesFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const skyLightsStart = moduleInstance.HEAPU32[skyLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];
            const torchLightsStart = moduleInstance.HEAPU32[torchLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT];

            const positionsCount = moduleInstance.HEAPU32[positionsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const uvsCount = moduleInstance.HEAPU32[uvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const atlasUvsCount = moduleInstance.HEAPU32[atlasUvsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const idsCount = moduleInstance.HEAPU32[idsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const indicesCount = moduleInstance.HEAPU32[indicesFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const skyLightsCount = moduleInstance.HEAPU32[skyLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];
            const torchLightsCount = moduleInstance.HEAPU32[torchLightsFreeEntry / Uint32Array.BYTES_PER_ELEMENT + 1];

            /* const _decodeArenaEntry = (allocator, freeEntry, constructor) => {
              const positionsBase = new Uint32Array(moduleInstance.HEAP8.buffer, allocator.ptr, 1)[0];
              const positionsOffset = new Uint32Array(moduleInstance.HEAP8.buffer, freeEntry, 1)[0];
              const positionsLength = new Uint32Array(moduleInstance.HEAP8.buffer, freeEntry + Uint32Array.BYTES_PER_ELEMENT, 1)[0];
              const positions = new constructor(moduleInstance.HEAP8.buffer, positionsBase + positionsOffset, positionsLength/constructor.BYTES_PER_ELEMENT);
              return positions;
            };
            const positions = _decodeArenaEntry(thingAllocators.positions, positionsFreeEntry, Float32Array);
            const uvs = _decodeArenaEntry(thingAllocators.uvs, uvsFreeEntry, Float32Array);
            const atlasUvs = _decodeArenaEntry(thingAllocators.atlasUvs, atlasUvsFreeEntry, Float32Array);
            const ids = _decodeArenaEntry(thingAllocators.ids, idsFreeEntry, Float32Array);
            const indices = _decodeArenaEntry(thingAllocators.indices, indicesFreeEntry, Uint32Array);
            const skyLights = _decodeArenaEntry(thingAllocators.skyLights, skyLightsFreeEntry, Uint8Array);
            const torchLights = _decodeArenaEntry(thingAllocators.torchLights, torchLightsFreeEntry, Uint8Array);
            console.log('got positions', {positions, uvs, atlasUvs, ids, indices, skyLights, torchLights}); */

            currentThingMesh.updateGeometry({
              positionsStart,
              uvsStart,
              atlasUvsStart,
              idsStart,
              indicesStart,
              skyLightsStart,
              torchLightsStart,

              positionsCount,
              uvsCount,
              atlasUvsCount,
              idsCount,
              indicesCount,
              skyLightsCount,
              torchLightsCount,
            });
          }

          callStack.allocRequest(METHODS.releaseAddRemoveObject, true, m2 => {
            m2.pushU32(tracker);
            m2.pushU32(numSubparcels);
            for (let i = 0; i < numSubparcels; i++) {
              m2.pushU32(m.pullU32());
            }
          }, m => {
            // console.log('done release', numSubparcels);
            accept();
          });
        });
      });
      w.convexHull = (positionsData, cameraPosition) => {
        const positions = geometryWorker.alloc(Float32Array, positionsData.length);
        positions.set(positionsData);

        cameraPosition.toArray(scratchStack.f32, 0);
        const convexHullResult = moduleInstance._convexHull(positions.byteOffset, positions.length, scratchStack.f32.byteOffset);

        const pointsOffset = moduleInstance.HEAPU32[convexHullResult / Uint32Array.BYTES_PER_ELEMENT];
        const numPoints = moduleInstance.HEAPU32[convexHullResult / Uint32Array.BYTES_PER_ELEMENT + 1];
        const points = moduleInstance.HEAPF32.slice(pointsOffset / Float32Array.BYTES_PER_ELEMENT, pointsOffset / Float32Array.BYTES_PER_ELEMENT + numPoints);
        const planeNormal = new THREE.Vector3().fromArray(moduleInstance.HEAPF32, convexHullResult / Float32Array.BYTES_PER_ELEMENT + 2);
        const planeConstant = moduleInstance.HEAPF32[convexHullResult / Uint32Array.BYTES_PER_ELEMENT + 5];
        const center = new THREE.Vector3().fromArray(moduleInstance.HEAPF32, convexHullResult / Float32Array.BYTES_PER_ELEMENT + 6);
        const tang = new THREE.Vector3().fromArray(moduleInstance.HEAPF32, convexHullResult / Float32Array.BYTES_PER_ELEMENT + 9);
        const bitang = new THREE.Vector3().fromArray(moduleInstance.HEAPF32, convexHullResult / Float32Array.BYTES_PER_ELEMENT + 12);

        w.free(positions.byteOffset);
        moduleInstance._deleteConvexHullResult(convexHullResult);

        return {
          points,
          planeNormal,
          planeConstant,
          center,
          tang,
          bitang,
        };
      };
      w.cookGeometryPhysics = (physics, mesh) => {
        mesh.updateMatrixWorld();
        const {geometry} = mesh;

        const allocator = new Allocator();
        const positions = allocator.alloc(Float32Array, geometry.attributes.position.count * 3);
        /* for (let i = 0, j = 0; i < positions.length; i += 3, j += geometry.attributes.position.data.stride) {
          localVector
            .fromArray(geometry.attributes.position.data.array, j)
            .applyMatrix4(mesh.matrixWorld)
            .toArray(positions, i);
        } */
        positions.set(geometry.attributes.position.array);
        const indices = allocator.alloc(Uint32Array, geometry.index.count);
        indices.set(geometry.index.array);
        moduleInstance._cookGeometryPhysics(
          physics,
          positions.byteOffset,
          indices.byteOffset,
          positions.length,
          indices.length,
          scratchStack.u32.byteOffset,
          scratchStack.u32.byteOffset + Uint32Array.BYTES_PER_ELEMENT,
          scratchStack.u32.byteOffset + Uint32Array.BYTES_PER_ELEMENT*2,
        );

        const dataPtr = scratchStack.u32[0];
        const dataLength = scratchStack.u32[1];
        const streamPtr = scratchStack.u32[2];
        
        const result = new Uint8Array(dataLength);
        result.set(new Uint8Array(moduleInstance.HEAP8.buffer, dataPtr, dataLength));
        allocator.freeAll();
        return result;
      };
      w.addGeometryPhysics = (physics, mesh) => {
        mesh.updateMatrixWorld();
        const {geometry} = mesh;

        const allocator = new Allocator();
        const positions = allocator.alloc(Float32Array, geometry.attributes.position.count * 3);
        /* for (let i = 0, j = 0; i < positions.length; i += 3, j += geometry.attributes.position.data.stride) {
          localVector
            .fromArray(geometry.attributes.position.data.array, j)
            .applyMatrix4(mesh.matrixWorld)
            .toArray(positions, i);
        } */
        positions.set(geometry.attributes.position.array);
        const indices = allocator.alloc(Uint32Array, geometry.index.count);
        indices.set(geometry.index.array);
        moduleInstance._cookGeometryPhysics(
          physics,
          positions.byteOffset,
          indices.byteOffset,
          positions.length,
          indices.length,
          scratchStack.u32.byteOffset,
          scratchStack.u32.byteOffset + Uint32Array.BYTES_PER_ELEMENT,
          scratchStack.u32.byteOffset + Uint32Array.BYTES_PER_ELEMENT*2,
        );
        allocator.freeAll();

        const dataPtr = scratchStack.u32[0];
        const dataLength = scratchStack.u32[1];
        const streamPtr = scratchStack.u32[2];
        
        {
          const b = new Blob([
            new Uint8Array(moduleInstance.HEAP8.buffer, dataPtr, dataLength),
          ], {
            type: 'application/octet-stream',
          });
          const u = URL.createObjectURL(b);
          console.log('got u', u);
        }

        moduleInstance._addGeometryPhysics(
          physics,
          dataPtr,
          dataLength,
          streamPtr,
        );
      };
      w.addCookedGeometryPhysics = (physics, buffer) => {
        const allocator = new Allocator();
        const buffer2 = allocator.alloc(Uint8Array, buffer.length);
        buffer2.set(buffer);
        moduleInstance._addGeometryPhysics(
          physics,
          buffer2.byteOffset,
          buffer2.byteLength,
          0,
        );
        allocator.freeAll();
      };
      /* w.earcut = (tracker, ps, holes, holeCounts, points, z, zs, objectId, position, quaternion) => {
        const inPs = w.alloc(Float32Array, ps.length);
        inPs.set(ps);
        const inHoles = w.alloc(Float32Array, holes.length);
        inHoles.set(holes);
        const inHoleCounts = w.alloc(Uint32Array, holeCounts.length);
        inHoleCounts.set(holeCounts);
        const inPoints = w.alloc(Float32Array, points.length);
        inPoints.set(points);
        const inZs = w.alloc(Float32Array, zs.length);
        inZs.set(zs);
        position.toArray(scratchStack.f32, 0);
        const positionOffset = scratchStack.f32.byteOffset;
        quaternion.toArray(scratchStack.f32, 3);
        const quaternionOffset = scratchStack.f32.byteOffset + 3 * Float32Array.BYTES_PER_ELEMENT;
        const resultOffset = moduleInstance._earcut(tracker, inPs.byteOffset, inPs.length / 2, inHoles.byteOffset, inHoleCounts.byteOffset, inHoleCounts.length, inPoints.byteOffset, inPoints.length, z, inZs.byteOffset, objectId, positionOffset, quaternionOffset);

        const outPositionsOffset = moduleInstance.HEAPU32[resultOffset / Uint32Array.BYTES_PER_ELEMENT];
        const outNumPositions = moduleInstance.HEAPU32[resultOffset / Uint32Array.BYTES_PER_ELEMENT + 1];
        const outUvsOffset = moduleInstance.HEAPU32[resultOffset / Uint32Array.BYTES_PER_ELEMENT + 2];
        const outNumUvs = moduleInstance.HEAPU32[resultOffset / Uint32Array.BYTES_PER_ELEMENT + 3];
        const outIndicesOffset = moduleInstance.HEAPU32[resultOffset / Uint32Array.BYTES_PER_ELEMENT + 4];
        const outNumIndices = moduleInstance.HEAPU32[resultOffset / Uint32Array.BYTES_PER_ELEMENT + 5];
        const trianglePhysicsGeometry = moduleInstance.HEAPU32[resultOffset / Uint32Array.BYTES_PER_ELEMENT + 6];
        const convexPhysicsGeometry = moduleInstance.HEAPU32[resultOffset / Uint32Array.BYTES_PER_ELEMENT + 7];

        const positions = moduleInstance.HEAPF32.subarray(outPositionsOffset / Float32Array.BYTES_PER_ELEMENT, outPositionsOffset / Float32Array.BYTES_PER_ELEMENT + outNumPositions);
        const uvs = moduleInstance.HEAPF32.subarray(outUvsOffset / Float32Array.BYTES_PER_ELEMENT, outUvsOffset / Float32Array.BYTES_PER_ELEMENT + outNumUvs);
        const indices = moduleInstance.HEAPU32.subarray(outIndicesOffset / Uint32Array.BYTES_PER_ELEMENT, outIndicesOffset / Uint32Array.BYTES_PER_ELEMENT + outNumIndices);

        w.free(inPs.byteOffset);
        w.free(inHoles.byteOffset);
        w.free(inHoleCounts.byteOffset);
        w.free(inPoints.byteOffset);
        w.free(inZs.byteOffset);

        return {
          resultOffset,

          positions,
          uvs,
          indices,
          trianglePhysicsGeometry,
          convexPhysicsGeometry,

          destroy() {
            moduleInstance._deleteEarcutResult(tracker, resultOffset);
          },
        };
      }; */
      w.addBoxGeometryPhysics = (physics, position, quaternion, size, id, dynamic) => {
        const allocator = new Allocator();
        const p = allocator.alloc(Float32Array, 3);
        const q = allocator.alloc(Float32Array, 4);
        const s = allocator.alloc(Float32Array, 3);
        
        position.toArray(p);
        quaternion.toArray(q);
        size.toArray(s);
        
        moduleInstance._addBoxGeometryPhysics(
          physics,
          p.byteOffset,
          q.byteOffset,
          s.byteOffset,
          id,
          +dynamic,
        );
        allocator.freeAll();
      };
      w.update = () => {
        if (moduleInstance) {
          if (geometryManager.currentChunkMesh) {
            const neededCoordsOffset = moduleInstance._updateNeededCoords(
              geometryManager.tracker,
              geometryManager.currentChunkMesh.currentPosition.x,
              geometryManager.currentChunkMesh.currentPosition.y,
              geometryManager.currentChunkMesh.currentPosition.z,
            );
            if (neededCoordsOffset) {
              const addedSubparcelsOffset = moduleInstance.HEAPU32[neededCoordsOffset / Uint32Array.BYTES_PER_ELEMENT];
              const numAddedSubparcels = moduleInstance.HEAPU32[neededCoordsOffset / Uint32Array.BYTES_PER_ELEMENT + 1];

              (async () => {
                for (let i = 0; i < numAddedSubparcels; i++) {
                  const subparcelOffset = moduleInstance.HEAP32[addedSubparcelsOffset / Uint32Array.BYTES_PER_ELEMENT + i];
                  /* const index = moduleInstance.HEAP32[subparcelOffset / Uint32Array.BYTES_PER_ELEMENT + 3];
                  const uint8Array = await storage.getRawTemp(`subparcel:${index}`); */
                  moduleInstance._subparcelUpdate(
                    geometryManager.tracker,
                    threadPool,
                    geometryManager.geometrySet,
                    neededCoordsOffset,
                    subparcelOffset,
                    1
                  );
                }
              })().then(() => {
                moduleInstance._finishUpdate(
                  geometryManager.tracker,
                  neededCoordsOffset,
                );
              });
            }
          }

          callStack.outNumEntriesU32[0] = maxNumMessages;
          moduleInstance._tick(
            threadPool,
            callStack.ptr,
            callStack.numEntries,
            callStack.outPtr,
            callStack.outNumEntriesPtr,
          );
          callStack.reset();
          const numMessages = callStack.outNumEntriesU32[0];
          for (let i = 0; i < numMessages; i++) {
            const offset = i*messageSize;
            const endMessage = new CallStackMessage(callStack.outPtr + offset);
            const id = endMessage.getId();
            const method = endMessage.getMethod();

            if (id > 0) {
              const cb = cbIndex.get(id);
              if (cb) {
                cb(endMessage);
                cbIndex.delete(id);
              } else {
                throw new Error('invalid callback id: ' + id);
              }
            } else if (id === -1) {
              const cb = MESSAGES[method];
              if (cb) {
                cb(endMessage);
              } else {
                throw new Error('invalid message method: ' + method);
              }
            } else {
              throw new Error('invalid id: ' + id);
            }
          }
        }
      };
      return w;
    })();

    await geometryWorker.waitForLoad();
    const physics = geometryWorker.makePhysics();

    let o = await new Promise((accept, reject) => {
      const u = URL.createObjectURL(file);
      new GLTFLoader().load(u, accept, function onprogress() {}, reject);
    });
    o = o.scene;
    o.updateMatrixWorld();
    let mesh = null;
    o.traverse(o => {
      if (!mesh && o.isMesh) {
        mesh = o;
      }
    });
    mesh.geometry.applyMatrix4(mesh.matrixWorld);
    mesh.position.set(0, 0, 0);
    mesh.quaternion.set(0, 0, 0, 1);
    mesh.scale.set(1, 1, 1);
    mesh.updateMatrixWorld();

    const physicsBuffer = await geometryWorker.cookGeometryPhysics(physics, mesh);
    const b = new Blob([physicsBuffer], {
      type: 'application/octet-stream',
    });
    downloadFile(b, 'target.bin');
  }
});
</script>
</body>
</html>